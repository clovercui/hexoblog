<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Clover Cui" />


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="Clover`S Blog">
<meta property="og:url" content="http://clover.htmhub.com/index.html">
<meta property="og:site_name" content="Clover`S Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Clover`S Blog">

<link rel="apple-touch-icon" href= "/hexoblog//apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Clover`S Blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/hexoblog//favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/hexoblog/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Clover`S Blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = /hexoblog/; </script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/hexoblog/" class="profilepic">
            <img src="/hexoblog//img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/hexoblog/">Clover Cui</a></h1>
        </hgroup>

        
        <p class="header-subtitle">克洛弗的博客</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="true" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/hexoblog/">主页</a></li>
                        
                            <li><a href="/hexoblog/archives/">所有文章</a></li>
                        
                            <li><a href="/hexoblog/tags/">标签云</a></li>
                        
                            <li><a href="/hexoblog/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:clover_cui@163.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/clovercui" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/hexoblog/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/hexoblog/tags/Clover/">Clover</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexoblog/tags/DB/">DB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexoblog/tags/Gulp/">Gulp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexoblog/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexoblog/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexoblog/tags/MonogoDB/">MonogoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexoblog/tags/PHP/">PHP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexoblog/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexoblog/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexoblog/tags/html/">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexoblog/tags/中文/">中文</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://clover.htmhub.com/">Clover</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Clover Cui</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/hexoblog/" class="profilepic">
                <img src="/hexoblog//img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/hexoblog/" title="回到主页">Clover Cui</a></h1>
            </hgroup>
            
            <p class="header-subtitle">克洛弗的博客</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/hexoblog/">主页</a></li>
                
                    <li><a href="/hexoblog/archives/">所有文章</a></li>
                
                    <li><a href="/hexoblog/tags/">标签云</a></li>
                
                    <li><a href="/hexoblog/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:clover_cui@163.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/clovercui" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/hexoblog/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-my-fist-blog" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/hexoblog/2016/08/26/my-fist-blog/" class="article-date">
      <time datetime="2016-08-26T05:33:14.000Z" itemprop="datePublished">2016-08-26</time>
</a>

 
    <a href="/hexoblog/2016/08/26/my-fist-blog/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/08/26/my-fist-blog/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexoblog/2016/08/26/my-fist-blog/">我的第一个博客</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><excerpt in="" index="" |="" 首页摘要=""><br>这里是摘要</excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""><br>这里是全文</the></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/hexoblog/categories/示例/">示例</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/Clover/">Clover</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/html/">html</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/中文/">中文</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>













  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/hexoblog/2016/08/26/hello-world/" class="article-date">
      <time datetime="2016-08-26T02:33:07.000Z" itemprop="datePublished">2016-08-26</time>
</a>

 
    <a href="/hexoblog/2016/08/26/hello-world/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/08/26/hello-world/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexoblog/2016/08/26/hello-world/">Hello World</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>













  
    <article id="post-2106-08-16-linux-file-encode" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/hexoblog/2016/08/16/2106-08-16-linux-file-encode/" class="article-date">
      <time datetime="2016-08-16T05:33:14.000Z" itemprop="datePublished">2016-08-16</time>
</a>

 
    <a href="/hexoblog/2016/08/16/2106-08-16-linux-file-encode/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/08/16/2106-08-16-linux-file-encode/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexoblog/2016/08/16/2106-08-16-linux-file-encode/">Linux文件加密之ccrypt</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="ccrypt"><a href="#ccrypt" class="headerlink" title="ccrypt"></a>ccrypt</h1><p><code>ccrypt是为了取代UNIX crypt而设计的，这个实用工具可用于文件和数据流加密及解密。它使用Rijndael密码</code></p>
<hr>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install ccrypt</div><div class="line">$ yum install ccrypt</div></pre></td></tr></table></figure>
<hr>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>加密文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ccencrypt filename</div></pre></td></tr></table></figure>
<p>输入两次密码</p>
<ul>
<li>解密文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ccdecrypt filename</div></pre></td></tr></table></figure>
<p>提供加密时输入的同一个密码才能解密</p>
<p>它使用ccencrypt来加密、使用ccdecrypt来解密。一定要注意，加密时，原始文件(tecmint.txt)换成了tecmint.txt.cpt;解密时，加密文件(tecmint.txt.cpt)换成了原始文件(tecmint.txt)。你可以使用ls命令来予以核查</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/hexoblog/categories/技术碎片/">技术碎片</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/Clover/">Clover</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/Linux/">Linux</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>













  
    <article id="post-2106-08-16-php-codes-encode" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/hexoblog/2016/08/16/2106-08-16-php-codes-encode/" class="article-date">
      <time datetime="2016-08-16T05:33:14.000Z" itemprop="datePublished">2016-08-16</time>
</a>

 
    <a href="/hexoblog/2016/08/16/2106-08-16-php-codes-encode/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/08/16/2106-08-16-php-codes-encode/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexoblog/2016/08/16/2106-08-16-php-codes-encode/">PHP源码加密模块 php-beast</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p><a href="https://github.com/liexusong/php-beast" target="_blank" rel="external">https://github.com/liexusong/php-beast</a></p>
</blockquote>
<pre><code>
  _____  _    _ _____    ____  ______           _____ _______
 |  __ \| |  | |  __ \  |  _ \|  ____|   /\    / ____|__   __|
 | |__) | |__| | |__) | | |_)/| |__     /  \  | (___    | |
 |  ___/|  __  |  ___/  |  _ ||  __|   / /\ \  \___ \   | |
 | |    | |  | | |      | |_)\| |____ / ____ \ ____) |  | |
 |_|    |_|  |_|_|      |____/|______/_/    \_\_____/   |_|
</code></pre>

<pre>
此模块可以用于商业用途, 版权归原作者.<br>
QQ交流群：239243332
</pre>

<p><b>php-beast可以自定义加密模块，加密模块编写教程: <a href="https://github.com/liexusong/php-beast/wiki/%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99%E6%95%99%E7%A8%8B" target="_blank" rel="external">点击</a></b></p>
<p></p><h3>编译安装如下:</h3><p></p>
<pre><code>
$ wget https://github.com/liexusong/php-beast/archive/master.zip
$ unzip master.zip
$ cd php-beast-master
$ phpize
$ ./configure --with-php-config=/usr/local/php/bin/php-config
$ sudo make && make install

编译好之后修改php.ini配置文件, 加入配置项: extension=beast.so, 重启php-fpm
</code></pre>

<pre>温馨提示: 可以设置较大的缓存提高效率</pre>

<p><b>使用php-beast的性能：</b><br><br><br><img src="http://git.oschina.net/liexusong/php-beast/raw/master/images/beast1.png?dir=0&filepath=images/beast1.png&oid=645b87003dada2eac4f1a9fcfd353aa0423f5711&sha=7ec2a0ddc7780b2bab538d9f49d8b262f1bc37b7"></p>

<p><b>不使用php-beast的性能：</b><br><br><br><img src="http://git.oschina.net/liexusong/php-beast/raw/master/images/beast2.png?dir=0&filepath=images/beast2.png&oid=3f07cff6dca34b22d8933ab0ea1740a0e4f37e34&sha=7ec2a0ddc7780b2bab538d9f49d8b262f1bc37b7"></p>

<p>配置项:</p>
<pre><code>
 beast.cache_size = size
 beast.log_file = "path_to_log"
 beast.enable = On
 beast.encrypt_handler = "des-algo"
</code></pre>

<p>支持的模块有：</p>
<pre>
 1. AES
 2. DES
 3. Base64
</pre>

<p>通过测试环境:</p>
<pre><code>
 Nginx + Fastcgi + (PHP-5.2.x ~ PHP-5.6.x)
</code></pre>

<p></p><h3>注意</h3><br>如果出现502错误，一般是由于GCC版本太低导致，请先升级GCC再安装本模块。<p></p>
<hr>
<h2 id="怎么加密项目"><a href="#怎么加密项目" class="headerlink" title="怎么加密项目"></a>怎么加密项目</h2><p>安装完 <code>php-beast</code> 后可以使用 <code>tools</code> 目录下的 <code>encode_files.php</code> 来加密你的项目。使用 <code>encode_files.php</code> 之前先修改 <code>tools</code> 目录下的 <code>configure.ini</code> 文件，如下：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">; source path</span></div><div class="line"><span class="attr">src_path</span> = <span class="string">""</span></div><div class="line"></div><div class="line"><span class="comment">; destination path</span></div><div class="line"><span class="attr">dst_path</span> = <span class="string">""</span></div><div class="line"></div><div class="line"><span class="comment">; expire time</span></div><div class="line"><span class="attr">expire</span> = <span class="string">""</span></div></pre></td></tr></table></figure></p>
<p><code>src_path</code> 是要加密项目的路径，<code>dst_path</code> 是保存加密后项目的路径，<code>expire</code> 是设置项目可使用的时间 (<code>expire</code> 的格式是：<code>YYYY-mm-dd HH:ii:ss</code>)。<br>修改完 <code>configure.ini</code> 文件后就可以使用命令 <code>php encode_files.php</code> 开始加密项目。</p>
<hr>
<h2 id="制定自己的php-beast"><a href="#制定自己的php-beast" class="headerlink" title="制定自己的php-beast"></a>制定自己的php-beast</h2><p><code>php-beast</code> 有多个地方可以定制的，以下一一列出：</p>
<p><em>1.</em> 使用 <code>header.c</code> 文件可以修改 <code>php-beast</code> 加密后的文件头结构，这样网上的解密软件就不能认识我们的加密文件，就不能进行解密，增加加密的安全性。</p>
<p><em>2.</em> <code>php-beast</code> 提供只能在指定的机器上运行的功能。要使用此功能可以在 <code>networkcards.c</code> 文件添加能够运行机器的网卡号，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *allow_networkcards[] = &#123;</div><div class="line">	<span class="string">"fa:16:3e:08:88:01"</span>,</div><div class="line">    <span class="literal">NULL</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这样设置之后，<code>php-beast</code> 扩展就只能在 <code>fa:16:3e:08:88:01</code> 这台机器上运行。另外要注意的是，由于有些机器网卡名可能不一样，所以如果你的网卡名不是 <code>eth0</code> 的话，可以在 <code>php.ini</code> 中添加配置项： <code>beast.networkcard = &quot;xxx&quot;</code> 其中 <code>xxx</code> 就是你的网卡名，也可以配置多张网卡，如：<code>beast.networkcard = &quot;eth0,eth1,eth2&quot;</code>。</p>
<p><em>3.</em> 使用 <code>php-beast</code> 时最好不要使用默认的加密key，因为扩展是开源的，如果使用默认加密key的话，很容易被人发现。所以最好编译的时候修改加密的key，<code>aes模块</code> 可以在 <code>aes_algo_handler.c</code> 文件修改，而 <code>des模块</code> 可以在 <code>des_algo_handler.c</code> 文件修改。</p>
<hr>
<h3 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h3><hr>
<ol>
<li><p>安装好php-beast喝php扩展</p>
</li>
<li><p>编写 php-beast-master/tools/configure.ini</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">; source path</span></div><div class="line"><span class="attr">src_path</span> = <span class="string">"/home/wwwroot/demo9.htmhub.com.bak"</span></div><div class="line"></div><div class="line"><span class="comment">; destination path</span></div><div class="line"><span class="attr">dst_path</span> = <span class="string">"/home/wwwroot/demo9.htmhub.com"</span></div><div class="line"></div><div class="line"><span class="comment">; expire time</span></div><div class="line"><span class="attr">expire</span> = <span class="string">""</span></div></pre></td></tr></table></figure>
</li>
<li><p>执行编译过程 </p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php  php-beast-master/tools/encode_files.php</div></pre></td></tr></table></figure>
<p>此时会将配置好的代码加密，解密过程是通过 beast.so 在线解密的。PHP文件可以正常访问。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/hexoblog/categories/技术碎片/">技术碎片</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/Clover/">Clover</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/PHP/">PHP</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>













  
    <article id="post-2016-07-04-redis-study-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/hexoblog/2016/07/04/2016-07-04-redis-study-2/" class="article-date">
      <time datetime="2016-07-04T05:33:14.000Z" itemprop="datePublished">2016-07-04</time>
</a>

 
    <a href="/hexoblog/2016/07/04/2016-07-04-redis-study-2/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/07/04/2016-07-04-redis-study-2/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexoblog/2016/07/04/2016-07-04-redis-study-2/">Redis Study 之二 入门指南</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>参考书籍：Redis入门指南（第二版）李子骅 编著 人民邮电出版社</p>
</blockquote>
<h1 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h1><h2 id="1）启动Redis"><a href="#1）启动Redis" class="headerlink" title="1）启动Redis"></a>1）启动Redis</h2><ol>
<li><p>直接启动</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># redis-server</span></div></pre></td></tr></table></figure>
</code></pre><p> Redis 服务器 默认 会 使用 6379 端口 ,通过– port 参数 可以 自定义 端口</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># redis-server --port 6380</span></div></pre></td></tr></table></figure>
</code></pre></li>
<li><p>通过初始化脚本启动（略过）        </p>
</li>
<li>指定配置文件启动<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># redis-server redis.conf</span></div></pre></td></tr></table></figure>
</code></pre></li>
</ol>
<h2 id="2）停止Redis"><a href="#2）停止Redis" class="headerlink" title="2）停止Redis"></a>2）停止Redis</h2><ul>
<li><p><strong>Redis有可能正在将内存中的数据同步到硬盘中，强行终止Redis进程可能会导致数据 丢失。 正确停止Redis的方式应该是向Redis发送SHUTDOWN 命令</strong></p>
<pre><code># redis-cli shutdown
</code></pre></li>
<li><p>当Redis收到shutdown命令后，会先断开所有的客户端连接，然后根据配置执行持久化，最后完成退出</p>
</li>
<li>Redis会妥善处理<code>sigterm</code>信号    ,所以使用kill Redis进程的PID也可以正常结束Redis,效果与发送shutdown命令一样。</li>
</ul>
<h2 id="3）Redis命令行客户端"><a href="#3）Redis命令行客户端" class="headerlink" title="3）Redis命令行客户端"></a>3）Redis命令行客户端</h2><p>redis-cli是Redis自带的基于命令行的Redis客户端</p>
<ol>
<li><p>发送命令</p>
<p> redis-cli向Redis发送命令有两种方式。</p>
<p> 一是将命令作为redis-cli的参数执行 ,<code>-h</code>自定义地址 <code>-p</code>自定义端口号</p>
<pre><code># redis-cli -h 127.0.0.1 -p 6379
</code></pre><p> redis提供<code>PING</code>命令来测试客户端语Redis连接是否正常</p>
<pre><code># redis-cli PING
PONG    
</code></pre><p> 二是不附带参数运行redis-cli，这样会进入交互模式可以自由输入命令</p>
<pre><code># redis-cli
redis 127.0.0.1:6379&gt; PING
PONG
redis 127.0.0.1:6379&gt; ECHO hi
&quot;hi&quot;
</code></pre></li>
<li><p>命令返回值</p>
<ul>
<li><p>状态回复</p>
<p>  状态是最简单的一种回复如SET 会回复OK    </p>
</li>
<li><p>错误回复</p>
<p>  当出现命令不存在或命令格式有错误时Redis会返回错误回复（error replay）.错误回复以（error）开头，并在后面跟上错误信息。如执行一个不存在的命令：</p>
<pre><code>redis&gt;ERRORCOMMEND
(error)ERR unknown command &apos;ERRORCOMMEND&apos;
</code></pre><p>  在 2. 6 版本 时， 错误 信息 均 是以“ ERR” 开头， 而在 2. 8 版 以后， 部分 错误 信息 会 以 具体 的 错误 类型 开头， 如： </p>
<pre><code>redis&gt; LPUSH key 1 (integer) 1
redis&gt; GET key 
(error) WRONGTYPE Operation against a key holding the wrong kind of value 
</code></pre><p>  这里 错误 信息 开头 的“ WRONGTYPE” 就 表示 类型 错误， 这个 改进 使得 在调 试    </p>
</li>
<li><p>整数回复<br>  Redis没有整数类型，但提供了用于整数操作的命令。整数回复以（integer）开头，并在后面跟上整数数据：</p>
<pre><code>redis&gt; INCR foo
(integer) 1
</code></pre></li>
<li><p>字符串回复<br>  字符串回复是最常见的一种回复类型，当请求一个字符串类型键的值或一个其他键中的某个元素时就会得到一个字符串。字符串回复以双引号包裹：</p>
<pre><code>redis&gt; GET foo
&quot;1&quot;        
</code></pre></li>
<li><p>多行字符串回复<br>  多行字符串回复中的每行字符串都以一个序号开头</p>
<pre><code>redis &gt; KEYS *
1) &quot;bar&quot;
2) &quot;foo&quot;
</code></pre></li>
</ul>
</li>
</ol>
<h2 id="4）配置"><a href="#4）配置" class="headerlink" title="4）配置"></a>4）配置</h2><p>通过<code>redis-server</code>的启动参数port设置了Redis的端口号，除此之外还有其他的配置选项，如开启持久化，日志级别等。由于配置选项多，redis支持通过配置文件来配置这些选        </p>
<pre><code>#redis-server /path/to/redis.conf
</code></pre><p>通过启动参数传递同名的配置选项会覆盖配置文件中相应的参数</p>
<pre><code>#redis-server /path/to/redis.conf --loglevel warning
</code></pre><p>Redis提供了一个配置文件的模板redis.conf位于源代码目录</p>
<p>还可以在运行时通过<code>CONFIG SET</code>    命令在不重启Redis的情况下动态修改部分Redis配置</p>
<pre><code>redis&gt;CONFIG SET loglevel warning
OK        
</code></pre><p>并不是所有的配置都可以使用CONFIG SET 命令修改        </p>
<h2 id="4）多数据库"><a href="#4）多数据库" class="headerlink" title="4）多数据库"></a>4）多数据库</h2><p>每个 数据库 对外 都是 以 一个 从 0 开始 的 递增 数字 命名， Redis 默认 支持 16 个 数据库， 可以 通过 配置 参数 databases 来 修改 这一 数字。 客户 端 与 Redis 建立 连接 后 会 自动 选择 0 号 数据库， 不过 可以 随时 使用SELECT命令更换数据库，如要选择1号数据库：</p>
<pre><code>redis&gt;SELECT 1
OK
redis[1] GET foo
(nil)
</code></pre><p>redis不支持自定义数据库的名字        </p>
<hr>
<h1 id="一、入门"><a href="#一、入门" class="headerlink" title="一、入门"></a>一、入门</h1><h2 id="1）字符串类型"><a href="#1）字符串类型" class="headerlink" title="1）字符串类型"></a>1）字符串类型</h2><p>一个字符串类型键允许存储的数据的最大容量是512M。</p>
<ol>
<li><p>赋值与取值</p>
<pre><code>SET key value
GET key  
</code></pre><p>set和get是redis中最简单的两个命令</p>
<p> 当键不存在时返回空结果</p>
</li>
<li><p>递增数字</p>
<pre><code>INCR key
</code></pre></li>
</ol>
<p>当存储的字符串是整数形式时，Redis提供了一个实用的命令INCR，其作用是让当键值递增，并返回递增后的值</p>
<pre><code>redis&gt;INCR num
(integer) 1
redis&gt;INCR num
(integer) 2
</code></pre><p>当要操作的键不存在时默认键值为0，所以第一次递增后的结果是1.</p>
<p>当键值不是整数是会提示错误</p>
<pre><code>redis&gt; SET foo lorem
OK 
redis&gt; INCR foo
(error) ERR value is not an integer or out of range
</code></pre><ol>
<li><p>命令拾遗</p>
<p> 1).增加指定的整数</p>
<pre><code>INCRBY key increment
INCRBY通过 increment 参数指定一次增加的数值
redis&gt; INCRBY bar 2
(integer)2
redis&gt; INCRBY bar 3
(integer)5
</code></pre><p> 2).减少指定的整数</p>
<pre><code>DECR key
DECRBY key increment
redis&gt; DECR bar 
(integer)4
</code></pre><p> 3).增加指定浮点数<br> INCRBYFLOAT key increment</p>
<p> 递增一个双精度浮点数    </p>
<pre><code>redis&gt;INCRBYFLOAT bar 2.7
&quot;6.7&quot;
redis&gt;INCRBYFLOAT bar 5E+4
&quot;50006.69999999999999929&quot;
</code></pre><p> 4).向尾部追加值<br> APPEND key value</p>
<p> APPEND 作用是向键值的末尾追加value.如果键不存在则将该值设置为value,即相当于SET key value.返回值是追加后字符串的总长度</p>
<pre><code>redis&gt;SET key hello
OK
redis&gt;APPEND key &quot; world!&quot;
（integer）12
</code></pre><p> 此时key的值是”hello world!”。APPEND命令的第二个参数加了双引号，原因是该参数包含空格，在redis-cli中输入需要双引号以示区分</p>
<p> 5).获取字符串长度</p>
<p> STRLEN key</p>
<p> STRLEN 命令返回键值的长度，如果键不存在返回0 </p>
<pre><code>redis&gt;STRLEN key
(interger)12
redis&gt;SET key 你好
OK
redis&gt;STRLEN key
(interger)6
</code></pre><p> 前面提到字符串类型可以存储二进制数据，所以它可以存储任意编码的字符串。例子中接收到的是使用UTF-8编码的中文，由于你好的UTF-8编码的长度都是3，所以返回6。</p>
<p> 6).同时获得/设置多个键值</p>
<p> MGET key[key …]</p>
<p> MMSET key value [key value …]</p>
<pre><code>redis&gt; MSET key1 v1 key2 v2 key3 v3
redis&gt; GET key2
&quot;v2&quot;
redis &gt; MGET key1 key3
1)&quot;v1&quot;
2)&quot;v3&quot;
</code></pre><p> 7). 位操作</p>
<p> GETBIT key offset</p>
<p> SETBIT key offset value</p>
<p> BITCOUNT key [start] [key …]</p>
<p> BITOP operation destkey key [key …]</p>
</li>
</ol>
<hr>
<h2 id="2）散列类型"><a href="#2）散列类型" class="headerlink" title="2）散列类型"></a>2）散列类型</h2><ol>
<li><p>赋值与取值</p>
<p> HSET key field value</p>
<p> HGET key field    </p>
<p> HMSET key field value [field value …]</p>
<p> HMGET key field [field …]</p>
<p> HGETALL key</p>
<pre><code>redis&gt; HSET car price 500
(interger)1
redis&gt; HSET car name BMW
(interger)1
redis&gt;HEGT car name
&quot;BMW&quot;
</code></pre><p> HSET命令方便之处在于不区分插入和更新操作，这意味着修改数据时不用事先判断字段是否存在来决定要执行的是插入操作还是更新操作。当执行的是插入操作时HSET会返回1，当执行的是更新操作是 HSET返回0。<code>当键本身不存在是，HSET命令还会自动创建</code>。</p>
<p> <code>REDIS中每个键都属于一个明确的数据类型，如通过HSET命令建立的键都是散列类型，通过SET命令建立的键是字符串类型。使用一种数据类型的命令操作另外一种数据类型的键会提示错误“ERR Operation against a key holding the wrong kind of value”</code>    </p>
<pre><code>redis&gt; HMGET car price name
1)&quot;500&quot;
2)&quot;BMW&quot;

redis&gt; HGETALL car  
1)&quot;price&quot;
2)&quot;500&quot;
3)&quot;name&quot;
4)&quot;BMW&quot;    
</code></pre></li>
<li><p>判断字段是否存在</p>
<p>HEXISTS key field</p>
<p>HEXISTS命令用来判断一个字段是否存在。如果存在则返回1，否则返回0（<code>如果键不存在也会返回0</code>）。</p>
<pre><code>redis&gt;HEXISTS car model
(integer)0
redis&gt;HSET car model C200
(integer)1
redis&gt;HEXISTS car model
(integer)1
</code></pre></li>
<li><p>当字段不存在时赋值</p>
<p> HSETNX key field value</p>
<p> HSETNX 命令与HSET命令相似，区别在于如果字段已经存在，HSETNX命令不执行任何操作</p>
<p> HSETNX 命令是原子操作，不用担心竞态条件</p>
</li>
<li><p>增加数字</p>
<p> HINCRBY key field increment</p>
<pre><code>redis&gt; HINCRBY person score 60
(integer)60
</code></pre><p> 之前person键不存在，HINCARBY命令会自动建立该键并默认score字段在执行前的值为0.命令的返回值是增值后的字段值</p>
</li>
<li><p>删除字段</p>
<p> HDELkey field [field]</p>
<p> HDEL 命令可以删除一个或者多个字段，返回值是被删除的字段个数</p>
<pre><code>redis&gt; HDEL car price
(integer)1
redis&gt; HDEL car price        
(integer)0
</code></pre></li>
</ol>
<ol>
<li><p>存储文章数据</p>
<pre><code>$postID=INCR posts:count
#判断用户输入的slug是否可用，如果可用则记录
$isSlugAvailable=HSETNX slug.to.id,$slug ,$postIID
if $isSlugAvailable is 0
#slug已经用过了需要提示更换slug
exit
HMSET post:$postID,title,$title,content,$content,slug,$slug,...
这段代码使用了HSETNX命令原子的实现了HEXISTS和HSET两个命令以避免竞态条件。当用户访问文章时，我们从网址中得到文章的缩略名，并查询slug.to.id键来获取文章ID：
$postID=HGET slug.to.id,$slug
if not $postID
print 文章不存在
exit
$post=HGETALL post:$postID
print文章标题:$post.title
需要注意的是如果要修改文章的缩略名一定不能忘了修改slug.to.id键对应的字段。
#判断新的slug是否可用，如果可用则记录
$isSlugAvailable=HSETNX slug.to.id ,$newSlug,42
if $isSlugAvailable is 0
exit
#获得旧的缩略名 
$oldSlug=HGET post:42,slug
#设置新的缩略名
HSET post:42,slug,$newSlug
#删除旧的缩略名
HDEL slug.to.id ,$oldslug
</code></pre></li>
<li><p>命令拾遗</p>
</li>
</ol>
<p>1）只获取字段名或字段值</p>
<p>HEKYS key</p>
<p>HVALS key</p>
<p>有时仅仅需要获取键中所有字段的名字而不需要字段值，那么可以使用HEKYS命令</p>
<pre><code>redis&gt; HKEYS car 
1)&quot;name&quot;
2)&quot;model&quot;
</code></pre><p>HVALS 命令与HEKYS命令相对应，HVALS命令用来获得键中所有字段值</p>
<pre><code>redis&gt; HVALS car
1)&quot;BMW&quot;
2)&quot;C200&quot;
</code></pre><p>2)获取字段数量</p>
<p>HLEN key</p>
<pre><code>redis&gt; HLEN car
(integer) 2                 
</code></pre><h2 id="3）列表类型"><a href="#3）列表类型" class="headerlink" title="3）列表类型"></a>3）列表类型</h2><ol>
<li><p>向列表两端增加元素</p>
<p> LPUSH key value [value …]</p>
<p> RPUSH key value [value …]</p>
<p> LPUSH命令用来向列表左边增加元素，返回值表示增加元素后列表的长度</p>
<pre><code>redis&gt; LPUSH numbers 1
(integer) 1

[1]

redis&gt; LPUSH numbers 2 3 
(integer) 3

[ 3 2 1 ]
</code></pre><p> LPUSH 会向列表左边先加入 2 再加入 3</p>
<pre><code>redis&gt; RPUSH numbers 0 -1
(integer) 5

[3 2 1 0 -1]    
</code></pre></li>
<li><p>从列表两端弹出元素</p>
<p> LPOP key</p>
<p> RPOP key </p>
<p> 有进有出，LPOP可以从列表左边弹出一个元素。LPOP命令执行两步操作：第一步是将列表左边的元素从列表移除，第二步是返回被移除的元素值</p>
<pre><code>redis&gt; LPOP numbers
&quot;3&quot;

redis&gt; RPOP numbers
&quot;-1&quot;
</code></pre><p> <code>结合上面提到的4个命令可以使用列表类型来模拟栈和队列的操作</code></p>
<p> <code>栈：LPUSH和LPOP   RPUSH和RPOP</code></p>
<p> <code>队列：LPUSH和RPOP  RPUSH和LPOP</code>    </p>
</li>
</ol>
<ol>
<li><p>获取列表中元素的个数</p>
<p> LLEN key</p>
<p> 当键不存在时LLEN会返回0</p>
<pre><code>redis&gt;LLEN numbers
(integer) 3
</code></pre><p> LLEN功能类似SQL语句 SELECT COUNT(*) FROM table_name 但是LLEN的时间复杂度为O(1) ,使用时Redis会直接读取现成的值，而不需要统计</p>
</li>
<li><p>获取列表片段</p>
<p> LRANGE key start stop</p>
<p> 返回索引从start到stop之间的所有元素（包含两端的元素），起始索引为0</p>
<pre><code>redis&gt; LRANGE numbers 0 2
1)&quot;2&quot;
2)&quot;1&quot;
3)&quot;0&quot;
</code></pre><p> LRANGE在取得列表片段的同时不会像LPOP一样删除该片段</p>
<p> LRANGE也支持负索引 表示从右边开始计算序数<br> -1 表示最右边第一个元素 -2便是最右边第二个元素</p>
<pre><code>redis&gt; LRANGE nubmers -2 -1
1)&quot;1&quot;
2)&quot;0&quot;    
</code></pre><p> 显然，LRANGE numbers 0 -1 可以获取列表中所有元素</p>
<p> <code>特殊情况</code></p>
<ul>
<li>如果start的索引位置比stop的索引位置靠后，返回空列表</li>
<li><p>如果stop大于实际的索引范围，则返回到列表最右边的元素</p>
<p>  redis&gt; LRANGE nubmers 1 999<br>  1)”1”<br>  2)”0”</p>
</li>
</ul>
</li>
<li><p>删除列表中指定的值</p>
<p> LREM key count value</p>
<p> LREM 会删除列表前count个值为value的元素，返回值是实际删除的元素个数，根据count值的不同，LREM执行方式有差异</p>
<ul>
<li>当count&gt;0时，LREM会从列表左边开始删除前count个值为value的元素</li>
<li>当count&lt;0时，LREM会从列表右边开始删除|count|个值为value的值</li>
<li>当count=0时，LREM会删除所有值为value的元素</li>
</ul>
</li>
<li><p>命令拾遗</p>
<p> 1.获得/设置指定索引的元素值</p>
<p> LINDEX key index</p>
<p> LSET key index value</p>
<p> LINDEX 返回指定索引的元素</p>
<pre><code>redis&gt; LINDEX numbers 0
&quot;2&quot;
redis&gt; LINDEX numbers -1
&quot;0&quot;
</code></pre><p> LSET是另一个通过索引操作列表的命令,它会将索引为index的元素赋值为value.例如</p>
<pre><code>redis&gt; LSET nubmers 1 7 
OK 
redis&gt; LINDEX nubmers 1
&quot;7&quot;            
</code></pre><p> 2.只保留列表指定片段</p>
<p> LTRIM key start end</p>
<p> LTRIM命令可以删除指定索引范围之外的所有元素，其指定列表范围的方法和LRANGE命令</p>
<pre><code>redis&gt; LRANGE numbers 0 -1
1)&quot;1&quot;
2)&quot;2&quot;
3)&quot;7&quot;
4)&quot;3&quot;
&quot;0&quot;
redis&gt; LTRIM numbers 1 2
OK
redis&gt; LRANGE numbers 0 1
1)&quot;2&quot;
2)&quot;7&quot;
</code></pre><p> LTRIM命令常和LPUSH命令一起来使用用来限制列表中元素的数量，比如日志只保留100条</p>
<p> LPUSHlogs $newlog</p>
<p> LTROM logs 0 99</p>
<p> 3.向列表中插入元素</p>
<p> LINSERT key BEFORE | AFTER pivot value</p>
<p> LINSERT 命令首先会在列表从左到右查找值为pivot的元素，然后根据BEFORE还是AFTER来决定将value插入到该元素的前面还是后面</p>
<pre><code>redis&gt; LRANGE numbers 0 -1
1)&quot;2&quot;
2)&quot;7&quot;
3)&quot;0&quot;
redis&gt; LINSERT numbers AFTER 7 3
(integer) 4
redis&gt; LRANGE numbers 0 -1
1)&quot;2&quot;
2)&quot;7&quot;
3)&quot;3&quot;
4)&quot;0&quot;
</code></pre><p> 4.将元素从一个列表转到另一个列表</p>
<p> RPOPLPUSH source destination</p>
<p> RPOPLPUSH功能：先执行RPOP命令再执行LPUSH命令。RPOPLPUSH命令会先从source列表类型键的右边弹出一个元素，然后将其加入到destination列表类型键的左边，并返回这个元素的值，整个过程是原子的。</p>
<p> 当把列表类型作为队列使用时，RPOPLPUSH命令可以很直观的在多个队列中传递数据。当source和destination相同时，RPOPLPUSH命令会不断地将对尾的元素移到队首，借助这个特性我们可以实现一个网站监控系统：使用一个队列存储需要监控的网址，然后监控程序不断地使用RPOPLPUSH命令循环取出一个网址来测试可用性。RPOPLPUSH的好处在于在程序执行过程中仍然可以不断的向网址列表中加入新网址，整个系统易扩展，允许多个客户端同时处理队列</p>
</li>
</ol>
<h2 id="4）集合类型"><a href="#4）集合类型" class="headerlink" title="4）集合类型"></a>4）集合类型</h2><p><code>在集合中的每个元素都是不同的，且没有顺序。一个集合类型（set）键可以存储之多232-1个字符串</code></p>
<ol>
<li><p>增加/删除元素</p>
<p> SADD key member [member …]</p>
<p> SREM key member [member …]</p>
<p> SADD命令用来向集合中增加一个或多个元素，如果键不存在则自动创建。因为一个集合中不能有相同的元素，相同键的元素会被忽略执行</p>
<pre><code>redis&gt; SADD letters a 
(integer) 1
redis&gt; SADD letters a b c
(integer) 2
</code></pre><p> 第二条SADD命令返回值为2是因为元素a已经存在，所以实际只加入了两个元素</p>
<p> SREM命令用来从集合正删除一个或者多个元素，并返回删除成功的个数</p>
<pre><code>redis&gt; SREM letters c d 
(integer) 1
</code></pre></li>
<li><p>获得集合中的所有元素</p>
<p> SMEMBERS key</p>
<p> SMEMBERS命令会返回集合中的所有元素</p>
<pre><code>redis&gt; SMEMBERS letters
1)&quot;b&quot;
2)&quot;a&quot;
</code></pre></li>
<li><p>判断元素是否在集合中</p>
<p> SMEMBERS key member</p>
<p> 判断一个元素是否在集合中是一个时间复杂度为O(1)的操作，无论集合元素多少，都可以很快速的返回结果。当值存在时SMEMBERS命令返回1，不存在返回0</p>
<pre><code>redis&gt; SMEMBERS letters a 
(integer) 1
redis&gt; SMEMBERS letters d
(integer) 0
</code></pre></li>
<li><p>集合间运算</p>
<p> SDIFF key [key …]<br> SINTER key [key …]<br> SUNION key [key …]        </p>
<p> SDIFF用来对多个集合执行差集运算</p>
</li>
</ol>
<h2 id="5）有序集合类型"><a href="#5）有序集合类型" class="headerlink" title="5）有序集合类型"></a>5）有序集合类型</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/hexoblog/categories/数据库/">数据库</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/Clover/">Clover</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/DB/">DB</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/Redis/">Redis</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>













  
    <article id="post-2016-06-30-gulp-study" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/hexoblog/2016/06/30/2016-06-30-gulp-study/" class="article-date">
      <time datetime="2016-06-30T04:00:00.000Z" itemprop="datePublished">2016-06-30</time>
</a>

 
    <a href="/hexoblog/2016/06/30/2016-06-30-gulp-study/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/06/30/2016-06-30-gulp-study/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexoblog/2016/06/30/2016-06-30-gulp-study/">Gulp-前端自动化构建工具</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Gulp-Web前端自动化开发工具"><a href="#Gulp-Web前端自动化开发工具" class="headerlink" title="Gulp-Web前端自动化开发工具"></a>Gulp-Web前端自动化开发工具</h1><hr>
<h3 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h3><p>####1. 全局安装 gulp</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --global gulp</div></pre></td></tr></table></figure>
<p>####2. 作为项目的开发依赖（devDependencies）安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev gulp</div></pre></td></tr></table></figure>
<p>####3. 在项目根目录下创建一个名为 gulpfile.js 的文件</p>
<pre><code class="js"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);

gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
  <span class="comment">// 将你的默认的任务代码放在这</span>
});
</code></pre>
<p>####4. 运行 gulp：</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/hexoblog/categories/开发工具/">开发工具</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/Clover/">Clover</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/Gulp/">Gulp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/HTML/">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/Web/">Web</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>













  
    <article id="post-2016-06-20-redis-study" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/hexoblog/2016/06/20/2016-06-20-redis-study/" class="article-date">
      <time datetime="2016-06-20T04:00:00.000Z" itemprop="datePublished">2016-06-20</time>
</a>

 
    <a href="/hexoblog/2016/06/20/2016-06-20-redis-study/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/06/20/2016-06-20-redis-study/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexoblog/2016/06/20/2016-06-20-redis-study/">Redis Study</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Redis的学习"><a href="#Redis的学习" class="headerlink" title="Redis的学习"></a>Redis的学习</h1><hr>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>最近几年来，关于持久化和数据查询的相关技术，其需求已经增长到了让人惊讶的程度。可以断言，关系型数据库再也不是放之四海皆准。换一句话说，围绕数据的解决方案不可能再只有唯一一种。</p>
<p>对于我来说，在众多新出现的解决方案和工具里，最让人兴奋的，无疑是Redis。为什么？首先是因为其让人不可思议的容易学习，只需要简短的几个小时学习时间，就能对Redis有个大概的认识。还有，Redis在处理一组特定的问题集的同时能保持相当的通用性。更准确地说就是，Redis不会尝试去解决关于数据的所有事情。在你足够了解Redis后，事情就会变得越来越清晰，什么是可行的，什么是不应该由Redis来处理的。作为一名开发人员，如此的经验当是相当的美妙。</p>
<p>当你能仅使用Redis去构建一个完整系统时，我想大多数人将会发现，Redis能使得他们的许多数据方案变得更为通用，不论是一个传统的关系型数据库，一个面向文档的系统，或是其它更多的东西。这是一种用来实现某些特定特性的解决方法。就类似于一个索引引擎，你不会在Lucene上构建整个程序，但当你需要足够好的搜索，为什么不使用它呢？这对你和你的用户都有好处。当然，关于Redis和索引引擎之间相似性的讨论到此为止。</p>
<p>本书的目的是向读者传授掌握Redis所需要的基本知识。我们将会注重于学习Redis的5种数据结构，并研究各种数据建模方法。我们还会接触到一些主要的管理细节和调试技巧。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><hr>
<p><code>windows</code>:<a href="https://github.com/dmajkic/redis/downloads" target="_blank" rel="external">https://github.com/dmajkic/redis/downloads</a></p>
<p><code>*nix和MacOSX平台</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ wget http://download.redis.io/releases/redis-3.2.0.tar.gz</div><div class="line">$ tar xzf redis-3.2.0.tar.gz</div><div class="line">$ cd redis-3.2.0</div><div class="line">$ make</div><div class="line">$ make install</div><div class="line">$ cp redis.conf /etc/</div><div class="line">$ cd /etc</div><div class="line">$ vim redis.conf</div><div class="line">修改daemonize yes---目的使进程在后台运行</div><div class="line">$ cd /usr/local/bin</div><div class="line">$./redis-server /etc/redis.conf</div></pre></td></tr></table></figure>
<p> 检查是否启动成功</p>
<p><code>$ ps -ef | grep redis</code></p>
<p>服务启动后通过 redis-cli链接<br>进入命令行控制台</p>
<p>（当然，Redis同样可以通过套件管理程序来安装。例如，使用Homebrew的MaxOSX用户可以只键入brew install redis即可。）</p>
<p>如果你是通过源文件来安装，二进制可执行文件会被放置在src目录里。通过运行cd src可跳转到src目录。</p>
<h2 id="运行和连接Redis"><a href="#运行和连接Redis" class="headerlink" title="运行和连接Redis"></a>运行和连接Redis</h2><hr>
<p>如果一切都工作正常，那Redis的二进制文件应该已经可以曼妙地跳跃于你的指尖之下。Redis只有少量的可执行文件，我们将着重于Redis的服务器和命令行界面（一个类DOS的客户端）。首先，让我们来运行服务器。在Windows平台，双击redis-server，在*nix/MacOSX平台则运行./redis-server.</p>
<p>如果你仔细看了启动信息，你会看到一个警告，指没能找到redis.conf文件。Redis将会采用内置的默认设置，这对于我们将要做的已经足够了。</p>
<p>然后，通过双击redis-cli（Windows平台）或者运行./redis-cli（*nix/MacOSX平台），启动Redis的控制台。控制台将会通过默认的端口（6379）来连接本地运行的服务器。</p>
<p>可以在命令行界面键入info命令来查看一切是不是都运行正常。你会很乐意看到这么一大组关键字-值（key-value）对的显示，这为我们查看服务器的状态提供了大量有效信息。</p>
<p>如果在上面的启动步骤里遇到什么问题，我建议你到<code>Redis的官方支持组</code>里获取帮助。</p>
<h2 id="驱动Redis"><a href="#驱动Redis" class="headerlink" title="驱动Redis"></a>驱动Redis</h2><hr>
<p>很快你就会发现，Redis的API就如一组定义明确的函数那般容易理解。Redis具有让人难以置信的简单性，其操作过程也同样如此。这意味着，无论你是使用命令行程序，或是使用你喜欢的语言来驱动，整体的感觉都不会相差多少。因此，相对于命令行程序，如果你更愿意通过一种编程语言去驱动Redis，你不会感觉到有任何适应的问题。如果真想如此，可以到Redis的<a href="http://redis.io/clients" target="_blank" rel="external">客户端推荐页面</a>下载适合的Redis载体。</p>
<hr>
<h2 id="学习-基础知识"><a href="#学习-基础知识" class="headerlink" title="学习-基础知识"></a>学习-基础知识</h2><hr>
<p>是什么使Redis显得这么特别？Redis具体能解决什么类型的问题？要实际应用Redis，开发者必须储备什么知识？在我们能回答这么一些问题之前，我们需要明白Redis到底是什么。</p>
<p>Redis通常被人们认为是一种持久化的存储器关键字-值型存储（in-memory persistent key-value store）。我认为这种对Redis的描述并不太准确。Redis的确是将所有的数据存放于存储器（更多是是按位存储），而且也确实通过将数据写入磁盘来实现持久化，但是Redis的实际意义比单纯的关键字-值型存储要来得深远。纠正脑海里的这种误解观点非常关键，否则你对于Redis之道以及其应用的洞察力就会变得越发狭义。</p>
<p>事实是，Redis引入了5种不同的数据结构，只有一个是典型的关键字-值型结构。理解Redis的关键就在于搞清楚这5种数据结构，其工作的原理都是如何，有什么关联方法以及你能怎样应用这些数据结构去构建模型。首先，让我们来弄明白这些数据结构的实际意义。</p>
<p>应用上面提及的数据结构概念到我们熟悉的关系型数据库里，我们可以认为其引入了一个单独的数据结构——表格。表格既复杂又灵活，基于表格的存储和管理，没有多少东西是你不能进行建模的。然而，这种通用性并不是没有缺点。具体来说就是，事情并不是总能达到假设中的简单或者快速。相对于这种普遍适用（one-size-fits-all）的结构体系，我们可以使用更为专门化的结构体系。当然，因此可能有些事情我们会完成不了(至少，达不到很好的程度）。但话说回来，这样做就能确定我们可以获得想象中的简单性和速度吗？</p>
<p>针对特定类型的问题使用特定的数据结构？我们不就是这样进行编程的吗？你不会使用一个散列表去存储每份数据，也不会使用一个标量变量去存储。对我来说，这正是Redis的做法。如果你需要处理标量、列表、散列或者集合，为什么不直接就用标量、列表、散列和集合去存储他们？为什么不是直接调用<code>exists(key)</code>去检测一个已存在的值，而是要调用其他比O(1)（常量时间查找，不会因为待处理元素的增长而变慢）慢的操作？</p>
<hr>
<h3 id="数据库（Databases）"><a href="#数据库（Databases）" class="headerlink" title="数据库（Databases）"></a>数据库（Databases）</h3><hr>
<p>与你熟悉的关系型数据库一致，Redis有着相同的数据库基本概念，即一个数据库包含一组数据。典型的数据库应用案例是，将一个程序的所有数据组织起来，使之与另一个程序的数据保持独立。</p>
<p>在Redis里，数据库简单的使用一个数字编号来进行辨认，默认数据库的数字编号是<code>0</code>。如果你想切换到一个不同的数据库，你可以使用<code>select</code>命令来实现。在命令行界面里键入<code>select 1</code>，Redis应该会回复一条<code>OK</code>的信息，然后命令行界面里的提示符会变成类似<code>redis 127.0.0.1:6379[1]&gt;</code>这样。如果你想切换回默认数据库，只要在命令行界面键入<code>select 0</code>即可。</p>
<hr>
<h3 id="命令、关键字和值（Commands-Keys-and-Values）"><a href="#命令、关键字和值（Commands-Keys-and-Values）" class="headerlink" title="命令、关键字和值（Commands, Keys and Values）"></a>命令、关键字和值（Commands, Keys and Values）</h3><hr>
<p>Redis不仅仅是一种简单的关键字-值型存储，从其核心概念来看，Redis的5种数据结构中的每一个都至少有一个关键字和一个值。在转入其它关于Redis的有用信息之前，我们必须理解关键字和值的概念。</p>
<p>关键字（Keys）是用来标识数据块。我们将会很常跟关键字打交道，不过在现在，明白关键字就是类似于<code>users:leto</code>这样的表述就足够了。一般都能很好地理解到，这样关键字包含的信息是一个名为<code>leto</code>的用户。这个关键字里的冒号没有任何特殊含义，对于Redis而言，使用分隔符来组织关键字是很常见的方法。</p>
<p>值（Values）是关联于关键字的实际值，可以是任何东西。有时候你会存储字符串，有时候是整数，还有时候你会存储序列化对象（使用JSON、XML或其他格式）。在大多数情况下，Redis会把值看做是一个字节序列，而不会关注它们实质上是什么。要注意，不同的Redis载体处理序列化会有所不同（一些会让你自己决定）。因此，在这本书里，我们将仅讨论字符串、整数和JSON。<br>现在让我们活动一下手指吧。在命令行界面键入下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set users:leto &quot;&#123;name: leto, planet: dune, likes: [spice]&#125;&quot;</div></pre></td></tr></table></figure>
<p>这就是Redis命令的基本构成。首先我们要有一个确定的命令，在上面的语句里就是set。然后就是相应的参数，set命令接受两个参数，包括要设置的关键字，以及相应要设置的值。很多的情况是，命令接受一个关键字（当这种情况出现，其经常是第一个参数）。你能想到如何去获取这个值吗？我想你会说（当然一时拿不准也没什么）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get users:leto</div></pre></td></tr></table></figure>
<p>关键字和值的是Redis的基本概念，而<code>get</code>和<code>set</code>命令是对此最简单的使用。你可以创建更多的用户，去尝试不同类型的关键字以及不同的值，看看一些不同的组合。</p>
<hr>
<h3 id="查询（Querying）"><a href="#查询（Querying）" class="headerlink" title="查询（Querying）"></a>查询（Querying）</h3><hr>
<p>随着学习的持续深入，两件事情将变得清晰起来。对于Redis而言，关键字就是一切，而值是没有任何意义。更通俗来看就是，Redis不允许你通过值来进行查询。回到上面的例子，我们就不能查询生活在<code>dune</code>行星上的用户。</p>
<p>对许多人来说，这会引起一些担忧。在我们生活的世界里，数据查询是如此的灵活和强大，而Redis的方式看起来是这么的原始和不高效。不要让这些扰乱你太久。要记住，Redis不是一种普遍使用（one-size-fits-all）的解决方案，确实存在这么一些事情是不应该由Redis来解决的（因为其查询的限制）。事实上，在考虑了这些情况后，你会找到新的方法去构建你的数据。</p>
<p>很快，我们就能看到更多实际的用例。很重要的一点是，我们要明白关于Redis的这些基本事实。这能帮助我们弄清楚为什么值可以是任何东西，因为Redis从来不需要去读取或理解它们。而且，这也可以帮助我们理清思路，然后去思考如何在这个新世界里建立模型。</p>
<h3 id="存储器和持久化（Memory-and-Persistence）"><a href="#存储器和持久化（Memory-and-Persistence）" class="headerlink" title="存储器和持久化（Memory and Persistence）"></a>存储器和持久化（Memory and Persistence）</h3><p>我们之前提及过，Redis是一种持久化的存储器内存储（in-memory persistent store）。对于持久化，默认情况下，Redis会根据已变更的关键字数量来进行判断，然后在磁盘里创建数据库的快照（snapshot）。你可以对此进行设置，如果X个关键字已变更，那么每隔Y秒存储数据库一次。默认情况下，如果1000个或更多的关键字已变更，Redis会每隔60秒存储数据库；而如果9个或更少的关键字已变更，Redis会每隔15分钟存储数据库。</p>
<p>除了创建磁盘快照外，Redis可以在附加模式下运行。任何时候，如果有一个关键字变更，一个单一附加（append-only）的文件会在磁盘里进行更新。在一些情况里，虽然硬件或软件可能发生错误，但用那60秒有效数据存储去换取更好性能是可以接受的。而在另一些情况里，这种损失就难以让人接受，Redis为你提供了选择。在第5章里，我们将会看到第三种选择，其将持久化任务减荷到一个从属数据库里。</p>
<p>至于存储器，Redis会将所有数据都保留在存储器中。显而易见，运行Redis具有不低的成本：因为RAM仍然是最昂贵的服务器硬件部件。</p>
<p>我很清楚有一些开发者对即使是一点点的数据空间都是那么的敏感。一本《威廉·莎士比亚全集》需要近5.5MB的存储空间。对于缩放的需求，其它的解决方案趋向于IO-bound或者CPU-bound。这些限制（RAM或者IO）将会需要你去理解更多机器实际依赖的数据类型，以及应该如何去进行存储和查询。除非你是存储大容量的多媒体文件到Redis中，否则存储器内存储应该不会是一个问题。如果这对于一个程序是个问题，你就很可能不会用IO-bound的解决方案。</p>
<p>Redis有虚拟存储器的支持。然而，这个功能已经被认为是失败的了（通过Redis的开发者），而且它的使用已经被废弃了。</p>
<p>（从另一个角度来看，一本5.5MB的《威廉·莎士比亚全集》可以通过压缩减小到近2MB。当然，Redis不会自动对值进行压缩，但是因为其将所有值都看作是字节，没有什么限制让你不能对数据进行压缩/解压，通过牺牲处理时间来换取存储空间。）</p>
<h3 id="整体来看（Putting-It-Together）"><a href="#整体来看（Putting-It-Together）" class="headerlink" title="整体来看（Putting It Together）"></a>整体来看（Putting It Together）</h3><p>我们已经接触了好几个高层次的主题。在继续深入Redis之前，我想做的最后一件事情是将这些主题整合起来。这些主题包括，查询的限制，数据结构以及Redis在存储器内存储数据的方法。</p>
<p>当你将这3个主题整合起来，你最终会得出一个绝妙的结论：速度。一些人可能会想，当然Redis会很快速，要知道所有的东西都在存储器里。但这仅仅是其中的一部分，让Redis闪耀的真正原因是其不同于其它解决方案的特殊数据结构。</p>
<p>能有多快速？这依赖于很多东西，包括你正在使用着哪个命令，数据的类型等等。但Redis的性能测试是趋向于数万或数十万次操作<strong>每秒</strong>。你可以通过运行<code>redis-benchmark</code>（就在<code>redis-server</code>和<code>redis-cli</code>的同一个文件夹里）来进行测试。</p>
<p>我曾经试过将一组使用传统模型的代码转向使用Redis。在传统模型里，运行一个我写的载入测试，需要超过5分钟的时间来完成。而在Redis里，只需要150毫秒就完成了。你不会总能得到这么好的收获，但希望这能让你对我们所谈的东西有更清晰的理解。</p>
<p>理解Redis的这个特性很重要，因为这将影响到你如何去与Redis进行交互。拥有SQL背景的程序员通常会致力于让数据库的数据往返次数减至最小。这对于任何系统都是个好建议，包括Redis。然而，考虑到我们是在处理比较简单的数据结构，有时候我们还是需要与Redis服务器频繁交互，以达到我们的目的。刚开始的时候，可能会对这种数据访问模式感到不太自然。实际上，相对于我们通过Redis获得的高性能而言，这仅仅是微不足道的损失。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>虽然我们只接触和摆弄了Redis的冰山一角，但我们讨论的主题已然覆盖了很大范围内的东西。如果觉得有些事情还是不太清楚（例如查询），不用为此而担心，在下一章我们将会继续深入探讨，希望你的问题都能得到解答。</p>
<p>这一章的要点包括：</p>
<ul>
<li><p>关键字（Keys）是用于标识一段数据的一个字符串</p>
</li>
<li><p>值（Values）是一段任意的字节序列，Redis不会关注它们实质上是什么</p>
</li>
<li><p>Redis展示了（也实现了）5种专门的数据结构</p>
</li>
<li><p>上面的几点使得Redis快速而且容易使用，但要知道Redis并不适用于所有的应用场景</p>
</li>
</ul>
<p>\clearpage</p>
<h2 id="第2章-数据结构"><a href="#第2章-数据结构" class="headerlink" title="第2章 - 数据结构"></a>第2章 - 数据结构</h2><p>现在开始将探究Redis的5种数据结构，我们会解释每种数据结构都是什么，包含了什么有效的方法（Method），以及你能用这些数据结构处理哪些类型的特性和数据。</p>
<p>目前为止，我们所知道的Redis构成仅包括命令、关键字和值，还没有接触到关于数据结构的具体概念。当我们使用<code>set</code>命令时，Redis是怎么知道我们是在使用哪个数据结构？其解决方法是，每个命令都相对应于一种特定的数据结构。例如，当你使用<code>set</code>命令，你就是将值存储到一个字符串数据结构里。而当你使用<code>hset</code>命令，你就是将值存储到一个散列数据结构里。考虑到Redis的关键字集很小，这样的机制具有相当的可管理性。</p>
<p><strong><a href="http://redis.io/commands" target="_blank" rel="external">Redis的网站</a>里有着非常优秀的参考文档，没有任何理由去重造轮子。但为了搞清楚这些数据结构的作用，我们将会覆盖那些必须知道的重要命令。</strong></p>
<p>没有什么事情比高兴的玩和试验有趣的东西来得更重要的了。在任何时候，你都能通过键入<code>flushdb</code>命令将你数据库里的所有值清除掉，因此，不要再那么害羞了，去尝试做些疯狂的事情吧！</p>
<h3 id="字符串（Strings"><a href="#字符串（Strings" class="headerlink" title="字符串（Strings)"></a>字符串（Strings)</h3><p>在Redis里，字符串是最基本的数据结构。当你在思索着关键字-值对时，你就是在思索着字符串数据结构。不要被名字给搞混了，如之前说过的，你的值可以是任何东西。我更喜欢将他们称作“标量”（Scalars），但也许只有我才这样想。</p>
<p>我们已经看到了一个常见的字符串使用案例，即通过关键字存储对象的实例。有时候，你会频繁地用到这类操作：</p>
<pre><code>set users:leto &quot;{name: leto, planet: dune, likes: [spice]}&quot;
</code></pre><p>除了这些外，Redis还有一些常用的操作。例如，<code>strlen &lt;key&gt;</code>能用来获取一个关键字对应值的长度；<code>getrange &lt;key&gt; &lt;start&gt; &lt;end&gt;</code>将返回指定范围内的关键字对应值；<code>append &lt;key&gt; &lt;value&gt;</code>会将value附加到已存在的关键字对应值中（如果该关键字并不存在，则会创建一个新的关键字-值对）。不要犹豫，去试试看这些命令吧。下面是我得到的：</p>
<pre><code>&gt; strlen users:leto
(integer) 42

&gt; getrange users:leto 27 40
&quot;likes: [spice]&quot;

&gt; append users:leto &quot; OVER 9000!!&quot;
(integer) 54
</code></pre><p>现在你可能会想，这很好，但似乎没有什么意义。你不能有效地提取出一段范围内的JSON文件，或者为其附加一些值。你是对的，这里的经验是，一些命令，尤其是关于字符串数据结构的，只有在给定了明确的数据类型后，才会有实际意义。</p>
<p>之前我们知道了，Redis不会去关注你的值是什么东西。通常情况下，这没有错。然而，一些字符串命令是专门为一些类型或值的结构而设计的。作为一个有些含糊的用例，我们可以看到，对于一些自定义的空间效率很高的（space-efficient）串行化对象，<code>append</code>和<code>getrange</code>命令将会很有用。对于一个更为具体的用例，我们可以再看一下<code>incr</code>、<code>incrby</code>、<code>decr</code>和<code>decrby</code>命令。这些命令会增长或者缩减一个字符串数据结构的值：</p>
<pre><code>&gt; incr stats:page:about
(integer) 1
&gt; incr stats:page:about
(integer) 2

&gt; incrby ratings:video:12333 5
(integer) 5
&gt; incrby ratings:video:12333 3
(integer) 8
</code></pre><p>由此你可以想象到，Redis的字符串数据结构能很好地用于分析用途。你还可以去尝试增长<code>users:leto</code>（一个不是整数的值），然后看看会发生什么（应该会得到一个错误）。</p>
<p>更为进阶的用例是<code>setbit</code>和<code>getbit</code>命令。“今天我们有多少个独立用户访问”是个在Web应用里常见的问题，有一篇<a href="http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/" target="_blank" rel="external">精彩的博文</a>，在里面可以看到Spool是如何使用这两个命令有效地解决此问题。对于1.28亿个用户，一部笔记本电脑在不到50毫秒的时间里就给出了答复，而且只用了16MB的存储空间。</p>
<p>最重要的事情不是在于你是否明白位图（Bitmaps)的工作原理，或者Spool是如何去使用这些命令，而是应该要清楚Redis的字符串数据结构比你当初所想的要有用许多。然而，最常见的应用案例还是上面我们给出的：存储对象（简单或复杂）和计数。同时，由于通过关键字来获取一个值是如此之快，字符串数据结构很常被用来缓存数据。</p>
<h3 id="散列（Hashes）"><a href="#散列（Hashes）" class="headerlink" title="散列（Hashes）"></a>散列（Hashes）</h3><p>我们已经知道把Redis称为一种关键字-值型存储是不太准确的，散列数据结构是一个很好的例证。你会看到，在很多方面里，散列数据结构很像字符串数据结构。两者显著的区别在于，散列数据结构提供了一个额外的间接层：一个域（Field）。因此，散列数据结构中的<code>set</code>和<code>get</code>是：</p>
<pre><code>hset users:goku powerlevel 9000
hget users:goku powerlevel
</code></pre><p>相关的操作还包括在同一时间设置多个域、同一时间获取多个域、获取所有的域和值、列出所有的域或者删除指定的一个域：</p>
<pre><code>hmset users:goku race saiyan age 737
hmget users:goku race powerlevel
hgetall users:goku
hkeys users:goku
hdel users:goku age
</code></pre><p>如你所见，散列数据结构比普通的字符串数据结构具有更多的可操作性。我们可以使用一个散列数据结构去获得更精确的描述，是存储一个用户，而不是一个序列化对象。从而得到的好处是能够提取、更新和删除具体的数据片段，而不必去获取或写入整个值。</p>
<p>对于散列数据结构，可以从一个经过明确定义的对象的角度来考虑，例如一个用户，关键之处在于要理解他们是如何工作的。从性能上的原因来看，这是正确的，更具粒度化的控制可能会相当有用。在下一章我们将会看到，如何用散列数据结构去组织你的数据，使查询变得更为实效。在我看来，这是散列真正耀眼的地方。</p>
<h3 id="列表（Lists）"><a href="#列表（Lists）" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h3><p>对于一个给定的关键字，列表数据结构让你可以存储和处理一组值。你可以添加一个值到列表里、获取列表的第一个值或最后一个值以及用给定的索引来处理值。列表数据结构维护了值的顺序，提供了基于索引的高效操作。为了跟踪在网站里注册的最新用户，我们可以维护一个<code>newusers</code>的列表：</p>
<pre><code>lpush newusers goku
ltrim newusers 0 50
</code></pre><p><strong>（译注：<code>ltrim</code>命令的具体构成是<code>LTRIM Key start stop</code>。要理解<code>ltrim</code>命令，首先要明白Key所存储的值是一个列表，理论上列表可以存放任意个值。对于指定的列表，根据所提供的两个范围参数start和stop，<code>ltrim</code>命令会将指定范围外的值都删除掉，只留下范围内的值。）</strong></p>
<p>首先，我们将一个新用户推入到列表的前端，然后对列表进行调整，使得该列表只包含50个最近被推入的用户。这是一种常见的模式。<code>ltrim</code>是一个具有O(N)时间复杂度的操作，N是被删除的值的数量。从上面的例子来看，我们总是在插入了一个用户后再进行列表调整，实际上，其将具有O(1)的时间复杂度（因为N将永远等于1）的常数性能。</p>
<p>这是我们第一次看到一个关键字的对应值索引另一个值。如果我们想要获取最近的10个用户的详细资料，我们可以运行下面的组合操作：</p>
<pre><code>keys = redis.lrange(&apos;newusers&apos;, 0, 10)
redis.mget(*keys.map {|u| &quot;users:#{u}&quot;})
</code></pre><p>我们之前谈论过关于多次往返数据的模式，上面的两行Ruby代码为我们进行了很好的演示。</p>
<p>当然，对于存储和索引关键字的功能，并不是只有列表数据结构这种方式。值可以是任意的东西，你可以使用列表数据结构去存储日志，也可以用来跟踪用户浏览网站时的路径。如果你过往曾构建过游戏，你可能会使用列表数据结构去跟踪用户的排队活动。</p>
<h3 id="集合（Sets）"><a href="#集合（Sets）" class="headerlink" title="集合（Sets）"></a>集合（Sets）</h3><p>集合数据结构常常被用来存储只能唯一存在的值，并提供了许多的基于集合的操作，例如并集。集合数据结构没有对值进行排序，但是其提供了高效的基于值的操作。使用集合数据结构的典型用例是朋友名单的实现：</p>
<pre><code>sadd friends:leto ghanima paul chani jessica
sadd friends:duncan paul jessica alia
</code></pre><p>不管一个用户有多少个朋友，我们都能高效地（O(1)时间复杂度）识别出用户X是不是用户Y的朋友：</p>
<pre><code>sismember friends:leto jessica
sismember friends:leto vladimir
</code></pre><p>而且，我们可以查看两个或更多的人是不是有共同的朋友：</p>
<pre><code>sinter friends:leto friends:duncan
</code></pre><p>甚至可以在一个新的关键字里存储结果：</p>
<pre><code>sinterstore friends:leto_duncan friends:leto friends:duncan
</code></pre><p>有时候需要对值的属性进行标记和跟踪处理，但不能通过简单的复制操作完成，集合数据结构是解决此类问题的最好方法之一。当然，对于那些需要运用集合操作的地方（例如交集和并集），集合数据结构就是最好的选择。</p>
<h3 id="分类集合（Sorted-Sets）"><a href="#分类集合（Sorted-Sets）" class="headerlink" title="分类集合（Sorted Sets）"></a>分类集合（Sorted Sets）</h3><p>最后也是最强大的数据结构是分类集合数据结构。如果说散列数据结构类似于字符串数据结构，主要区分是域（field）的概念；那么分类集合数据结构就类似于集合数据结构，主要区分是标记（score）的概念。标记提供了排序（sorting）和秩划分（ranking）的功能。如果我们想要一个秩分类的朋友名单，可以这样做：</p>
<pre><code>zadd friends:duncan 70 ghanima 95 paul 95 chani 75 jessica 1 vladimir
</code></pre><p>对于<code>duncan</code>的朋友，要怎样计算出标记（score）为90或更高的人数？</p>
<pre><code>zcount friends:duncan 90 100
</code></pre><p>如何获取<code>chani</code>在名单里的秩（rank）？</p>
<pre><code>zrevrank friends:duncan chani
</code></pre><p><strong>（译注：<code>zrank</code>命令的具体构成是<code>ZRANK Key menber</code>，要知道Key存储的Sorted Set默认是根据Score对各个menber进行升序的排列，该命令就是用来获取menber在该排列里的次序，这就是所谓的秩。）</strong></p>
<p>我们使用了<code>zrevrank</code>命令而不是<code>zrank</code>命令，这是因为Redis的默认排序是从低到高，但是在这个例子里我们的秩划分是从高到低。对于分类集合数据结构，最常见的应用案例是用来实现排行榜系统。事实上，对于一些基于整数排序，且能以标记（score）来进行有效操作的东西，使用分类集合数据结构来处理应该都是不错的选择。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>对于Redis的5种数据结构，我们进行了高层次的概述。一件有趣的事情是，相对于最初构建时的想法，你经常能用Redis创造出一些更具实效的事情。对于字符串数据结构和分类集合数据结构的使用，很有可能存在一些构建方法是还没有人想到的。当你理解了那些常用的应用案例后，你将发现Redis对于许多类型的问题，都是很理想的选择。还有，不要因为Redis展示了5种数据结构和相应的各种方法，就认为你必须要把所有的东西都用上。只使用一些命令去构建一个特性是很常见的。</p>
<p>\clearpage</p>
<h2 id="第3章-使用数据结构"><a href="#第3章-使用数据结构" class="headerlink" title="第3章 - 使用数据结构"></a>第3章 - 使用数据结构</h2><p>在上一章里，我们谈论了Redis的5种数据结构，对于一些可能的用途也给出了用例。现在是时候来看看一些更高级，但依然很常见的主题和设计模式。</p>
<h3 id="大O表示法（Big-O-Notation）"><a href="#大O表示法（Big-O-Notation）" class="headerlink" title="大O表示法（Big O Notation）"></a>大O表示法（Big O Notation）</h3><p>在本书中，我们之前就已经看到过大O表示法，包括O(1)和O(N)的表示。大O表示法的惯常用途是，描述一些用于处理一定数量元素的行为的综合表现。在Redis里，对于一个要处理一定数量元素的命令，大O表示法让我们能了解该命令的大概运行速度。</p>
<p>在Redis的文档里，每一个命令的时间复杂度都用大O表示法进行了描述，还能知道各命令的具体性能会受什么因素影响。让我们来看看一些用例。</p>
<p>常数时间复杂度O(1)被认为是最快速的，无论我们是在处理5个元素还是5百万个元素，最终都能得到相同的性能。对于<code>sismember</code>命令，其作用是告诉我们一个值是否属于一个集合，时间复杂度为O(1)。<code>sismember</code>命令很强大，很大部分的原因是其高效的性能特征。许多Redis命令都具有O(1)的时间复杂度。</p>
<p>对数时间复杂度O(log(N))被认为是第二快速的，其通过使需扫描的区间不断皱缩来快速完成处理。使用这种“分而治之”的方式，大量的元素能在几个迭代过程里被快速分解完整。<code>zadd</code>命令的时间复杂度就是O(log(N))，其中N是在分类集合中的元素数量。</p>
<p>再下来就是线性时间复杂度O(N)，在一个表格的非索引列里进行查找就需要O(N)次操作。<code>ltrim</code>命令具有O(N)的时间复杂度，但是，在<code>ltrim</code>命令里，N不是列表所拥有的元素数量，而是被删除的元素数量。从一个具有百万元素的列表里用<code>ltrim</code>命令删除1个元素，要比从一个具有一千个元素的列表里用<code>ltrim</code>命令删除10个元素来的快速（实际上，两者很可能会是一样快，因为两个时间都非常的小）。</p>
<p>根据给定的最小和最大的值的标记，<code>zremrangebyscore</code>命令会在一个分类集合里进行删除元素操作，其时间复杂度是O(log(N)+M)。这看起来似乎有点儿杂乱，通过阅读文档可以知道，这里的N指的是在分类集合里的总元素数量，而M则是被删除的元素数量。可以看出，对于性能而言，被删除的元素数量很可能会比分类集合里的总元素数量更为重要。</p>
<p><strong>（译注：<code>zremrangebyscore</code>命令的具体构成是<code>ZREMRANGEBYSCORE Key max mix</code>。）</strong></p>
<p>对于<code>sort</code>命令，其时间复杂度为O(N+M*log(M))，我们将会在下一章谈论更多的相关细节。从<code>sort</code>命令的性能特征来看，可以说这是Redis里最复杂的一个命令。</p>
<p>还存在其他的时间复杂度描述，包括O(N^2)和O(C^N)。随着N的增大，其性能将急速下降。在Redis里，没有任何一个命令具有这些类型的时间复杂度。</p>
<p>值得指出的一点是，在Redis里，当我们发现一些操作具有O(N)的时间复杂度时，我们可能可以找到更为好的方法去处理。</p>
<p><strong>（译注：对于Big O Notation，相信大家都非常的熟悉，虽然原文仅仅是对该表示法进行简单的介绍，但限于个人的算法知识和文笔水平实在有限，此小节的翻译让我头痛颇久，最终成果也确实难以让人满意，望见谅。）</strong></p>
<h3 id="仿多关键字查询（Pseudo-Multi-Key-Queries）"><a href="#仿多关键字查询（Pseudo-Multi-Key-Queries）" class="headerlink" title="仿多关键字查询（Pseudo Multi Key Queries）"></a>仿多关键字查询（Pseudo Multi Key Queries）</h3><p>时常，你会想通过不同的关键字去查询相同的值。例如，你会想通过电子邮件（当用户开始登录时）去获取用户的具体信息，或者通过用户id（在用户登录后）去获取。有一种很不实效的解决方法，其将用户对象分别放置到两个字符串值里去：</p>
<pre><code>set users:leto@dune.gov &quot;{id: 9001, email: &apos;leto@dune.gov&apos;, ...}&quot;
set users:9001 &quot;{id: 9001, email: &apos;leto@dune.gov&apos;, ...}&quot;
</code></pre><p>这种方法很糟糕，如此不但会产生两倍数量的内存，而且这将会成为数据管理的恶梦。</p>
<p>如果Redis允许你将一个关键字链接到另一个的话，可能情况会好很多，可惜Redis并没有提供这样的功能（而且很可能永远都不会提供）。Redis发展到现在，其开发的首要目的是要保持代码和API的整洁简单，关键字链接功能的内部实现并不符合这个前提（对于关键字，我们还有很多相关方法没有谈论到）。其实，Redis已经提供了解决的方法：散列。</p>
<p>使用散列数据结构，我们可以摆脱重复的缠绕：</p>
<pre><code>set users:9001 &quot;{id: 9001, email: leto@dune.gov, ...}&quot;
hset users:lookup:email leto@dune.gov 9001
</code></pre><p>我们所做的是，使用域来作为一个二级索引，然后去引用单个用户对象。要通过id来获取用户信息，我们可以使用一个普通的<code>get</code>命令：</p>
<pre><code>get users:9001
</code></pre><p>而如果想通过电子邮箱来获取用户信息，我们可以使用<code>hget</code>命令再配合使用<code>get</code>命令（Ruby代码）：</p>
<pre><code>id = redis.hget(&apos;users:lookup:email&apos;, &apos;leto@dune.gov&apos;)
user = redis.get(&quot;users:#{id}&quot;)
</code></pre><p>你很可能将会经常使用这类用法。在我看来，这就是散列真正耀眼的地方。在你了解这类用法之前，这可能不是一个明显的用例。</p>
<h3 id="引用和索引（References-and-Indexes）"><a href="#引用和索引（References-and-Indexes）" class="headerlink" title="引用和索引（References and Indexes）"></a>引用和索引（References and Indexes）</h3><p>我们已经看过几个关于值引用的用例，包括介绍列表数据结构时的用例，以及在上面使用散列数据结构来使查询更灵活一些。进行归纳后会发现，对于那些值与值间的索引和引用，我们都必须手动的去管理。诚实来讲，这确实会让人有点沮丧，尤其是当你想到那些引用相关的操作，如管理、更新和删除等，都必须手动的进行时。在Redis里，这个问题还没有很好的解决方法。</p>
<p>我们已经看到，集合数据结构很常被用来实现这类索引：</p>
<pre><code>sadd friends:leto ghanima paul chani jessica
</code></pre><p>这个集合里的每一个成员都是一个Redis字符串数据结构的引用，而每一个引用的值则包含着用户对象的具体信息。那么如果<code>chani</code>改变了她的名字，或者删除了她的帐号，应该如何处理？从整个朋友圈的关系结构来看可能会更好理解，我们知道，<code>chani</code>也有她的朋友：</p>
<pre><code>sadd friends_of:chani leto paul
</code></pre><p>如果你有什么待处理情况像上面那样，那在维护成本之外，还会有对于额外索引值的处理和存储空间的成本。这可能会令你感到有点退缩。在下一小节里，我们将会谈论减少使用额外数据交互的性能成本的一些方法（在第1章我们粗略地讨论了下）。</p>
<p>如果你确实在担忧着这些情况，其实，关系型数据库也有同样的开销。索引需要一定的存储空间，必须通过扫描或查找，然后才能找到相应的记录。其开销也是存在的，当然他们对此做了很多的优化工作，使之变得更为有效。</p>
<p>再次说明，需要在Redis里手动地管理引用确实是颇为棘手。但是，对于你关心的那些问题，包括性能或存储空间等，应该在经过测试后，才会有真正的理解。我想你会发现这不会是一个大问题。</p>
<h3 id="数据交互和流水线（Round-Trips-and-Pipelining）"><a href="#数据交互和流水线（Round-Trips-and-Pipelining）" class="headerlink" title="数据交互和流水线（Round Trips and Pipelining）"></a>数据交互和流水线（Round Trips and Pipelining）</h3><p>我们已经提到过，与服务器频繁交互是Redis的一种常见模式。这类情况可能很常出现，为了使我们能获益更多，值得仔细去看看我们能利用哪些特性。</p>
<p>许多命令能接受一个或更多的参数，也有一种关联命令（sister-command）可以接受多个参数。例如早前我们看到过<code>mget</code>命令，接受多个关键字，然后返回值：</p>
<pre><code>keys = redis.lrange(&apos;newusers&apos;, 0, 10)
redis.mget(*keys.map {|u| &quot;users:#{u}&quot;})
</code></pre><p>或者是<code>sadd</code>命令，能添加一个或多个成员到集合里：</p>
<pre><code>sadd friends:vladimir piter
sadd friends:paul jessica leto &quot;leto II&quot; chani
</code></pre><p>Redis还支持流水线功能。通常情况下，当一个客户端发送请求到Redis后，在发送下一个请求之前必须等待Redis的答复。使用流水线功能，你可以发送多个请求，而不需要等待Redis响应。这不但减少了网络开销，还能获得性能上的显著提高。</p>
<p>值得一提的是，Redis会使用存储器去排列命令，因此批量执行命令是一个好主意。至于具体要多大的批量，将取决于你要使用什么命令（更明确来说，该参数有多大）。另一方面来看，如果你要执行的命令需要差不多50个字符的关键字，你大概可以对此进行数千或数万的批量操作。</p>
<p>对于不同的Redis载体，在流水线里运行命令的方式会有所差异。在Ruby里，你传递一个代码块到<code>pipelined</code>方法：</p>
<pre><code>redis.pipelined do
  9001.times do
    redis.incr(&apos;powerlevel&apos;)
  end
end
</code></pre><p>正如你可能猜想到的，流水线功能可以实际地加速一连串命令的处理。</p>
<h3 id="事务（Transactions）"><a href="#事务（Transactions）" class="headerlink" title="事务（Transactions）"></a>事务（Transactions）</h3><p>每一个Redis命令都具有原子性，包括那些一次处理多项事情的命令。此外，对于使用多个命令，Redis支持事务功能。</p>
<p>你可能不知道，但Redis实际上是单线程运行的，这就是为什么每一个Redis命令都能够保证具有原子性。当一个命令在执行时，没有其他命令会运行（我们会在往后的章节里简略谈论一下Scaling）。在你考虑到一些命令去做多项事情时，这会特别的有用。例如：</p>
<p><code>incr</code>命令实际上就是一个<code>get</code>命令然后紧随一个<code>set</code>命令。</p>
<p><code>getset</code>命令设置一个新的值然后返回原始值。</p>
<p><code>setnx</code>命令首先测试关键字是否存在，只有当关键字不存在时才设置值</p>
<p>虽然这些都很有用，但在实际开发时，往往会需要运行具有原子性的一组命令。若要这样做，首先要执行<code>multi</code>命令，紧随其后的是所有你想要执行的命令（作为事务的一部分），最后执行<code>exec</code>命令去实际执行命令，或者使用<code>discard</code>命令放弃执行命令。Redis的事务功能保证了什么？</p>
<ul>
<li><p>事务中的命令将会按顺序地被执行</p>
</li>
<li><p>事务中的命令将会如单个原子操作般被执行（没有其它的客户端命令会在中途被执行）</p>
</li>
<li><p>事务中的命令要么全部被执行，要么不会执行</p>
</li>
</ul>
<p>你可以（也应该）在命令行界面对事务功能进行一下测试。还有一点要注意到，没有什么理由不能结合流水线功能和事务功能。</p>
<pre><code>multi
hincrby groups:1percent balance -9000000000
hincrby groups:99percent balance 9000000000
exec
</code></pre><p>最后，Redis能让你指定一个关键字（或多个关键字），当关键字有改变时，可以查看或者有条件地应用一个事务。这是用于当你需要获取值，且待运行的命令基于那些值时，所有都在一个事务里。对于上面展示的代码，我们不能去实现自己的<code>incr</code>命令，因为一旦<code>exec</code>命令被调用，他们会全部被执行在一块。我们不能这么做：</p>
<pre><code>redis.multi()
current = redis.get(&apos;powerlevel&apos;)
redis.set(&apos;powerlevel&apos;, current + 1)
redis.exec()
</code></pre><p><strong>（译注：虽然Redis是单线程运行的，但是我们可以同时运行多个Redis客户端进程，常见的并发问题还是会出现。像上面的代码，在<code>get</code>运行之后，<code>set</code>运行之前，<code>powerlevel</code>的值可能会被另一个Redis客户端给改变，从而造成错误。）</strong></p>
<p>这些不是Redis的事务功能的工作。但是，如果我们增加一个<code>watch</code>到<code>powerlevel</code>，我们可以这样做：</p>
<pre><code>redis.watch(&apos;powerlevel&apos;)
current = redis.get(&apos;powerlevel&apos;)
redis.multi()
redis.set(&apos;powerlevel&apos;, current + 1)
redis.exec()
</code></pre><p>在我们调用<code>watch</code>后，如果另一个客户端改变了<code>powerlevel</code>的值，我们的事务将会运行失败。如果没有客户端改变<code>powerlevel</code>的值，那么事务会继续工作。我们可以在一个循环里运行这些代码，直到其能正常工作。</p>
<h3 id="关键字反模式（Keys-Anti-Pattern）"><a href="#关键字反模式（Keys-Anti-Pattern）" class="headerlink" title="关键字反模式（Keys Anti-Pattern）"></a>关键字反模式（Keys Anti-Pattern）</h3><p>在下一章中，我们将会谈论那些没有确切关联到数据结构的命令，其中的一些是管理或调试工具。然而有一个命令我想特别地在这里进行谈论：<code>keys</code>命令。这个命令需要一个模式，然后查找所有匹配的关键字。这个命令看起来很适合一些任务，但这不应该用在实际的产品代码里。为什么？因为这个命令通过线性扫描所有的关键字来进行匹配。或者，简单地说，这个命令太慢了。</p>
<p>人们会如此去使用这个命令？一般会用来构建一个本地的Bug追踪服务。每一个帐号都有一个<code>id</code>，你可能会通过一个看起来像<code>bug:account_id:bug_id</code>的关键字，把每一个Bug存储到一个字符串数据结构值中去。如果你在任何时候需要查询一个帐号的Bug（显示它们，或者当用户删除了帐号时删除掉这些Bugs），你可能会尝试去使用<code>keys</code>命令：</p>
<pre><code>keys bug:1233:*
</code></pre><p>更好的解决方法应该使用一个散列数据结构，就像我们可以使用散列数据结构来提供一种方法去展示二级索引，因此我们可以使用域来组织数据：</p>
<pre><code>hset bugs:1233 1 &quot;{id:1, account: 1233, subject: &apos;...&apos;}&quot;
hset bugs:1233 2 &quot;{id:2, account: 1233, subject: &apos;...&apos;}&quot;
</code></pre><p>从一个帐号里获取所有的Bug标识，可以简单地调用<code>hkeys bugs:1233</code>。去删除一个指定的Bug，可以调用<code>hdel bugs:1233 2</code>。如果要删除了一个帐号，可以通过<code>del bugs:1233</code>把关键字删除掉。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>结合这一章以及前一章，希望能让你得到一些洞察力，了解如何使用Redis去支持（Power）实际项目。还有其他的模式可以让你去构建各种类型的东西，但真正的关键是要理解基本的数据结构。你将能领悟到，这些数据结构是如何能够实现你最初视角之外的东西。</p>
<p>\clearpage</p>
<h2 id="第4章-超越数据结构"><a href="#第4章-超越数据结构" class="headerlink" title="第4章 超越数据结构"></a>第4章 超越数据结构</h2><p>5种数据结构组成了Redis的基础，其他没有关联特定数据结构的命令也有很多。我们已经看过一些这样的命令：<code>info</code>, <code>select</code>, <code>flushdb</code>, <code>multi</code>, <code>exec</code>, <code>discard</code>, <code>watch</code>和<code>keys</code>。这一章将看看其他的一些重要命令。</p>
<h3 id="使用期限（Expiration）"><a href="#使用期限（Expiration）" class="headerlink" title="使用期限（Expiration）"></a>使用期限（Expiration）</h3><p>Redis允许你标记一个关键字的使用期限。你可以给予一个Unix时间戳形式（自1970年1月1日起）的绝对时间，或者一个基于秒的存活时间。这是一个基于关键字的命令，因此其不在乎关键字表示的是哪种类型的数据结构。</p>
<pre><code>expire pages:about 30
expireat pages:about 1356933600
</code></pre><p>第一个命令将会在30秒后删除掉关键字（包括其关联的值）。第二个命令则会在2012年12月31日上午12点删除掉关键字。</p>
<p>这让Redis能成为一个理想的缓冲引擎。通过<code>ttl</code>命令，你可以知道一个关键字还能够存活多久。而通过<code>persist</code>命令，你可以把一个关键字的使用期限删除掉。</p>
<pre><code>ttl pages:about
persist pages:about
</code></pre><p>最后，有个特殊的字符串命令，<code>setex</code>命令让你可以在一个单独的原子命令里设置一个字符串值，同时里指定一个生存期（这比任何事情都要方便）。</p>
<pre><code>setex pages:about 30 &apos;&lt;h1&gt;about us&lt;/h1&gt;....&apos;
</code></pre><h3 id="发布和订阅（Publication-and-Subscriptions）"><a href="#发布和订阅（Publication-and-Subscriptions）" class="headerlink" title="发布和订阅（Publication and Subscriptions）"></a>发布和订阅（Publication and Subscriptions）</h3><p>Redis的列表数据结构有<code>blpop</code>和<code>brpop</code>命令，能从列表里返回且删除第一个（或最后一个）元素，或者被堵塞，直到有一个元素可供操作。这可以用来实现一个简单的队列。</p>
<p><strong>（译注：对于<code>blpop</code>和<code>brpop</code>命令，如果列表里没有关键字可供操作，连接将被堵塞，直到有另外的Redis客户端使用<code>lpush</code>或<code>rpush</code>命令推入关键字为止。）</strong></p>
<p>此外，Redis对于消息发布和频道订阅有着一流的支持。你可以打开第二个<code>redis-cli</code>窗口，去尝试一下这些功能。在第一个窗口里订阅一个频道（我们会称它为<code>warnings</code>）：</p>
<pre><code>subscribe warnings
</code></pre><p>其将会答复你订阅的信息。现在，在另一个窗口，发布一条消息到<code>warnings</code>频道：</p>
<pre><code>publish warnings &quot;it&apos;s over 9000!&quot;
</code></pre><p>如果你回到第一个窗口，你应该已经接收到<code>warnings</code>频道发来的消息。</p>
<p>你可以订阅多个频道（<code>subscribe channel1 channel2 ...</code>），订阅一组基于模式的频道（<code>psubscribe warnings:*</code>），以及使用<code>unsubscribe</code>和<code>punsubscribe</code>命令停止监听一个或多个频道，或一个频道模式。</p>
<p>最后，可以注意到<code>publish</code>命令的返回值是1，这指出了接收到消息的客户端数量。</p>
<h3 id="监控和延迟日志（Monitor-and-Slow-Log）"><a href="#监控和延迟日志（Monitor-and-Slow-Log）" class="headerlink" title="监控和延迟日志（Monitor and Slow Log）"></a>监控和延迟日志（Monitor and Slow Log）</h3><p><code>monitor</code>命令可以让你查看Redis正在做什么。这是一个优秀的调试工具，能让你了解你的程序如何与Redis进行交互。在两个<code>redis-cli</code>窗口中选一个（如果其中一个还处于订阅状态，你可以使用<code>unsubscribe</code>命令退订，或者直接关掉窗口再重新打开一个新窗口）键入<code>monitor</code>命令。在另一个窗口，执行任何其他类型的命令（例如<code>get</code>或<code>set</code>命令）。在第一个窗口里，你应该可以看到这些命令，包括他们的参数。</p>
<p>在实际生产环境里，你应该谨慎运行<code>monitor</code>命令，这真的仅仅就是一个很有用的调试和开发工具。除此之外，没有更多要说的了。</p>
<p>随同<code>monitor</code>命令一起，Redis拥有一个<code>slowlog</code>命令，这是一个优秀的性能剖析工具。其会记录执行时间超过一定数量<strong>微秒</strong>的命令。在下一章节，我们会简略地涉及如何配置Redis，现在你可以按下面的输入配置Redis去记录所有的命令：</p>
<pre><code>config set slowlog-log-slower-than 0
</code></pre><p>然后，执行一些命令。最后，你可以检索到所有日志，或者检索最近的那些日志：</p>
<pre><code>slowlog get
slowlog get 10
</code></pre><p>通过键入<code>slowlog len</code>，你可以获取延迟日志里的日志数量。</p>
<p>对于每个被你键入的命令，你应该查看4个参数：</p>
<ul>
<li><p>一个自动递增的id</p>
</li>
<li><p>一个Unix时间戳，表示命令开始运行的时间</p>
</li>
<li><p>一个微妙级的时间，显示命令运行的总时间</p>
</li>
<li><p>该命令以及所带参数</p>
</li>
</ul>
<p>延迟日志保存在存储器中，因此在生产环境中运行（即使有一个低阀值）也应该不是一个问题。默认情况下，它将会追踪最近的1024个日志。</p>
<h3 id="排序（Sort）"><a href="#排序（Sort）" class="headerlink" title="排序（Sort）"></a>排序（Sort）</h3><p><code>sort</code>命令是Redis最强大的命令之一。它让你可以在一个列表、集合或者分类集合里对值进行排序（分类集合是通过标记来进行排序，而不是集合里的成员）。下面是一个<code>sort</code>命令的简单用例：</p>
<pre><code>rpush users:leto:guesses 5 9 10 2 4 10 19 2
sort users:leto:guesses
</code></pre><p>这将返回进行升序排序后的值。这里有一个更高级的例子：</p>
<pre><code>sadd friends:ghanima leto paul chani jessica alia duncan
sort friends:ghanima limit 0 3 desc alpha
</code></pre><p>上面的命令向我们展示了，如何对已排序的记录进行分页（通过<code>limit</code>），如何返回降序排序的结果（通过<code>desc</code>），以及如何用字典序排序代替数值序排序（通过<code>alpha</code>）。</p>
<p><code>sort</code>命令的真正力量是其基于引用对象来进行排序的能力。早先的时候，我们说明了列表、集合和分类集合很常被用于引用其他的Redis对象，<code>sort</code>命令能够解引用这些关系，而且通过潜在值来进行排序。例如，假设我们有一个Bug追踪器能让用户看到各类已存在问题。我们可能使用一个集合数据结构去追踪正在被监视的问题：</p>
<pre><code>sadd watch:leto 12339 1382 338 9338
</code></pre><p>你可能会有强烈的感觉，想要通过id来排序这些问题（默认的排序就是这样的），但是，我们更可能是通过问题的严重性来对这些问题进行排序。为此，我们要告诉Redis将使用什么模式来进行排序。首先，为了可以看到一个有意义的结果，让我们添加多一点数据：</p>
<pre><code>set severity:12339 3
set severity:1382 2
set severity:338 5
set severity:9338 4
</code></pre><p>要通过问题的严重性来降序排序这些Bug，你可以这样做：</p>
<pre><code>sort watch:leto by severity:* desc
</code></pre><p>Redis将会用存储在列表（集合或分类集合）中的值去替代模式中的<code>*</code>（通过<code>by</code>）。这会创建出关键字名字，Redis将通过查询其实际值来排序。</p>
<p>在Redis里，虽然你可以有成千上万个关键字，类似上面展示的关系还是会引起一些混乱。幸好，<code>sort</code>命令也可以工作在散列数据结构及其相关域里。相对于拥有大量的高层次关键字，你可以利用散列：</p>
<pre><code>hset bug:12339 severity 3
hset bug:12339 priority 1
hset bug:12339 details &quot;{id: 12339, ....}&quot;

hset bug:1382 severity 2
hset bug:1382 priority 2
hset bug:1382 details &quot;{id: 1382, ....}&quot;

hset bug:338 severity 5
hset bug:338 priority 3
hset bug:338 details &quot;{id: 338, ....}&quot;

hset bug:9338 severity 4
hset bug:9338 priority 2
hset bug:9338 details &quot;{id: 9338, ....}&quot;
</code></pre><p>所有的事情不仅变得更为容易管理，而且我们能通过<code>severity</code>或<code>priority</code>来进行排序，还可以告诉<code>sort</code>命令具体要检索出哪一个域的数据：</p>
<pre><code>sort watch:leto by bug:*-&gt;priority get bug:*-&gt;details
</code></pre><p>相同的值替代出现了，但Redis还能识别<code>-&gt;</code>符号，用它来查看散列中指定的域。里面还包括了<code>get</code>参数，这里也会进行值替代和域查看，从而检索出Bug的细节（details域的数据）。</p>
<p>对于太大的集合，<code>sort</code>命令的执行可能会变得很慢。好消息是，<code>sort</code>命令的输出可以被存储起来：</p>
<pre><code>sort watch:leto by bug:*-&gt;priority get bug:*-&gt;details store watch_by_priority:leto
</code></pre><p>使用我们已经看过的<code>expiration</code>命令，再结合<code>sort</code>命令的<code>store</code>能力，这是一个美妙的组合。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>这一章主要关注那些非特定数据结构关联的命令。和其他事情一样，它们的使用依情况而定。构建一个程序或特性时，可能不会用到使用期限、发布和订阅或者排序等功能。但知道这些功能的存在是很好的。而且，我们也只接触到了一些命令。还有更多的命令，当你消化理解完这本书后，非常值得去浏览一下<a href="http://redis.io/commands" target="_blank" rel="external">完整的命令列表</a>。</p>
<p>\clearpage</p>
<h2 id="第5章-管理"><a href="#第5章-管理" class="headerlink" title="第5章 - 管理"></a>第5章 - 管理</h2><p>在最后一章里，我们将集中谈论Redis运行中的一些管理方面内容。这是一个不完整的Redis管理指南，我们将会回答一些基本的问题，初接触Redis的新用户可能会很感兴趣。</p>
<h3 id="配置（Configuration）"><a href="#配置（Configuration）" class="headerlink" title="配置（Configuration）"></a>配置（Configuration）</h3><p>当你第一次运行Redis的服务器，它会向你显示一个警告，指<code>redis.conf</code>文件没有被找到。这个文件可以被用来配置Redis的各个方面。一个充分定义（well-documented）的<code>redis.conf</code>文件对各个版本的Redis都有效。范例文件包含了默认的配置选项，因此，对于想要了解设置在干什么，或默认设置是什么，都会很有用。你可以在<a href="https://github.com/antirez/redis/raw/2.4.6/redis.conf" target="_blank" rel="external">https://github.com/antirez/redis/raw/2.4.6/redis.conf</a>找到这个文件。</p>
<p><strong>这个配置文件针对的是Redis 2.4.6，你应该用你的版本号替代上面URL里的”2.4.6”。运行<code>info</code>命令，其显示的第一个值就是Redis的版本号。</strong></p>
<p>因为这个文件已经是充分定义（well-documented），我们就不去再进行设置了。</p>
<p>除了通过<code>redis.conf</code>文件来配置Redis，<code>config set</code>命令可以用来对个别值进行设置。实际上，在将<code>slowlog-log-slower-than</code>设置为0时，我们就已经使用过这个命令了。</p>
<p>还有一个<code>config get</code>命令能显示一个设置值。这个命令支持模式匹配，因此如果我们想要显示关联于日志（logging）的所有设置，我们可以这样做：</p>
<pre><code>config get *log*
</code></pre><h3 id="验证（Authentication）"><a href="#验证（Authentication）" class="headerlink" title="验证（Authentication）"></a>验证（Authentication）</h3><p>通过设置<code>requirepass</code>（使用<code>config set</code>命令或<code>redis.conf</code>文件），可以让Redis需要一个密码验证。当<code>requirepass</code>被设置了一个值（就是待用的密码），客户端将需要执行一个<code>auth password</code>命令。</p>
<p>一旦一个客户端通过了验证，就可以在任意数据库里执行任何一条命令，包括<code>flushall</code>命令，这将会清除掉每一个数据库里的所有关键字。通过配置，你可以重命名一些重要命令为混乱的字符串，从而获得一些安全性。</p>
<pre><code>rename-command CONFIG 5ec4db169f9d4dddacbfb0c26ea7e5ef
rename-command FLUSHALL 1041285018a942a4922cbf76623b741e
</code></pre><p>或者，你可以将新名字设置为一个空字符串，从而禁用掉一个命令。</p>
<h3 id="大小限制（Size-Limitations）"><a href="#大小限制（Size-Limitations）" class="headerlink" title="大小限制（Size Limitations）"></a>大小限制（Size Limitations）</h3><p>当你开始使用Redis，你可能会想知道，我能使用多少个关键字？还可能想知道，一个散列数据结构能有多少个域（尤其是当你用它来组织数据时），或者是，一个列表数据结构或集合数据结构能有多少个元素？对于每一个实例，实际限制都能达到亿万级别（hundreds of millions）。</p>
<h3 id="复制（Replication）"><a href="#复制（Replication）" class="headerlink" title="复制（Replication）"></a>复制（Replication）</h3><p>Redis支持复制功能，这意味着当你向一个Redis实例（Master）进行写入时，一个或多个其他实例（Slaves）能通过Master实例来保持更新。可以在配置文件里设置<code>slaveof</code>，或使用<code>slaveof</code>命令来配置一个Slave实例。对于那些没有进行这些设置的Redis实例，就可能一个Master实例。</p>
<p>为了更好保护你的数据，复制功能拷贝数据到不同的服务器。复制功能还能用于改善性能，因为读取请求可以被发送到Slave实例。他们可能会返回一些稍微滞后的数据，但对于大多数程序来说，这是一个值得做的折衷。</p>
<p>遗憾的是，Redis的复制功能还没有提供自动故障恢复。如果Master实例崩溃了，一个Slave实例需要手动的进行升级。如果你想使用Redis去达到某种高可用性，对于使用心跳监控（heartbeat monitoring）和脚本自动开关（scripts to automate the switch）的传统高可用性工具来说，现在还是一个棘手的难题。</p>
<h3 id="备份文件（Backups）"><a href="#备份文件（Backups）" class="headerlink" title="备份文件（Backups）"></a>备份文件（Backups）</h3><p>备份Redis非常简单，你可以将Redis的快照（snapshot）拷贝到任何地方，包括S3、FTP等。默认情况下，Redis会把快照存储为一个名为<code>dump.rdb</code>的文件。在任何时候，你都可以对这个文件执行<code>scp</code>、<code>ftp</code>或<code>cp</code>等常用命令。</p>
<p>有一种常见情况，在Master实例上会停用快照以及单一附加文件（aof），然后让一个Slave实例去处理备份事宜。这可以帮助减少Master实例的载荷。在不损害整体系统响应性的情况下，你还可以在Slave实例上设置更多主动存储的参数。</p>
<h3 id="缩放和Redis集群（Scaling-and-Redis-Cluster）"><a href="#缩放和Redis集群（Scaling-and-Redis-Cluster）" class="headerlink" title="缩放和Redis集群（Scaling and Redis Cluster）"></a>缩放和Redis集群（Scaling and Redis Cluster）</h3><p>复制功能（Replication）是一个成长中的网站可以利用的第一个工具。有一些命令会比另外一些来的昂贵（例如<code>sort</code>命令），将这些运行载荷转移到一个Slave实例里，可以保持整体系统对于查询的快速响应。</p>
<p>此外，通过分发你的关键字到多个Redis实例里，可以达到真正的缩放Redis（记住，Redis是单线程的，这些可以运行在同一个逻辑框里）。随着时间的推移，你将需要特别注意这些事情（尽管许多的Redis载体都提供了consistent-hashing算法）。对于数据水平分布（horizontal distribution）的考虑不在这本书所讨论的范围内。这些东西你也很可能不需要去担心，但是，无论你使用哪一种解决方案，有一些事情你还是必须意识到。</p>
<p>好消息是，这些工作都可在Redis集群下进行。不仅提供水平缩放（包括均衡），为了高可用性，还提供了自动故障恢复。</p>
<p>高可用性和缩放是可以达到的，只要你愿意为此付出时间和精力，Redis集群也使事情变得简单多了。</p>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>在过去的一段时间里，已经有许多的计划和网站使用了Redis，毫无疑问，Redis已经可以应用于实际生产中了。然而，一些工具还是不够成熟，尤其是一些安全性和可用性相关的工具。对于Redis集群，我们希望很快就能看到其实现，这应该能为一些现有的管理挑战提供处理帮忙。</p>
<p>\clearpage</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在许多方面，Redis体现了一种简易的数据处理方式，其剥离掉了大部分的复杂性和抽象，并可有效的在不同系统里运行。不少情况下，选择Redis不是最佳的选择。在另一些情况里，Redis就像是为你的数据提供了特别定制的解决方案。</p>
<p>最终，回到我最开始所说的：Redis很容易学习。现在有许多的新技术，很难弄清楚哪些才真正值得我们花时间去学习。如果你从实际好处来考虑，Redis提供了他的简单性。我坚信，对于你和你的团队，学习Redis是最好的技术投资之一。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/hexoblog/categories/数据库/">数据库</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/Clover/">Clover</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/DB/">DB</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/Redis/">Redis</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>













  
    <article id="post-2016-05-2-monogo-db-study" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/hexoblog/2016/05/20/2016-05-2-monogo-db-study/" class="article-date">
      <time datetime="2016-05-20T05:00:00.000Z" itemprop="datePublished">2016-05-20</time>
</a>

 
    <a href="/hexoblog/2016/05/20/2016-05-2-monogo-db-study/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
            <span class="ds-thread-count"  data-thread-key="2016/05/20/2016-05-2-monogo-db-study/" ></span>
        
        
    </a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexoblog/2016/05/20/2016-05-2-monogo-db-study/">Monogo DB Study</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="MonogoDB-学习笔记"><a href="#MonogoDB-学习笔记" class="headerlink" title="MonogoDB  学习笔记"></a>MonogoDB  学习笔记</h1><hr>
<p>#入门篇</p>
<hr>
<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><hr>
<h4 id="Mongo-概念"><a href="#Mongo-概念" class="headerlink" title="Mongo 概念"></a>Mongo 概念</h4><ul>
<li><code>mongo</code> <code>MongoDB</code> <code>索引</code> <code>集合</code> <code>复制集</code> <code>分片</code> <code>数据均衡</code></li>
</ul>
<h4 id="学会MongoDB的搭建"><a href="#学会MongoDB的搭建" class="headerlink" title="学会MongoDB的搭建"></a>学会MongoDB的搭建</h4><ul>
<li>搭建简单的单击服务</li>
<li>搭建具有冗余容错功能的复制集</li>
<li>搭建大规模数据集群</li>
<li>完成集群的自动部署</li>
</ul>
<h4 id="MongoDB的使用"><a href="#MongoDB的使用" class="headerlink" title="MongoDB的使用"></a>MongoDB的使用</h4><ul>
<li>最基本的文档的读写和更新</li>
<li>各种不同类型的索引的创建与使用</li>
<li>复杂的聚合查询</li>
<li>对数据集合进行分片，在不同分片间维持数据均衡</li>
<li>数据备份与恢复</li>
<li>数据迁移</li>
</ul>
<h4 id="简单运维"><a href="#简单运维" class="headerlink" title="简单运维"></a>简单运维</h4><ul>
<li>部署集群</li>
<li><p>处理多种常见的故障</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"> 单节点失效，如何恢复工作</div><div class="line"> 数据库意外被杀死如何进行数据恢复</div><div class="line"> 数据库拒绝服务如何排除原因</div><div class="line"> 数据库磁盘快慢时如何处理</div><div class="line"> </div><div class="line"> ``` </div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">## 学习资源</div><div class="line">---</div><div class="line">* **MongoDB官网** `www.mongodb.org`</div><div class="line">* **MongoDB中国官网** `www.mongoing.com`</div><div class="line">* **github** `https://github.com/mongodb/mongo`</div><div class="line">* **中文文档** `docs.mongoing.com`</div><div class="line">* **视频资源** `http://www.imooc.com/video/5934`</div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">#开始学习</div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">## 数据库</div><div class="line"></div><div class="line">---</div><div class="line">### 概念</div><div class="line">1. 有组织的存放数据</div><div class="line">2. 按照不同的需求进行查询</div><div class="line"></div><div class="line">### 数据库分类</div><div class="line">1. sql数据库：支持sql语言的数据库 Oracle,Mysql</div><div class="line">2. NoSql数据库：不支持SQL语言的数据库 Redis,MongoDB</div><div class="line"></div><div class="line">Sql 数据库 | NoSql数据库 </div><div class="line">----------|------------- </div><div class="line">实时一致性   	  | 简单便捷 </div><div class="line">事务          |方便扩展</div><div class="line">多表联合查询   | 更好的性能</div><div class="line"></div><div class="line">### 为什么是MongoDB</div><div class="line">1. 无数据结构的限制</div><div class="line">	1. 没有表结构的概念，每条记录可以有完全不同的结构</div><div class="line">	2. 业务开发方便快捷</div><div class="line">	3. sql数据库需要先定义表结构再使用</div></pre></td></tr></table></figure>
<p>  {name:”小明”,sex:”男”}<br>  {name:”小明”,address:”上海”}<br>  {name:”小明”,home:[{“山东”},{“江西”}]}</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2. 完全的索引支持</div><div class="line">	1. redis的key-value</div><div class="line">	2. hbase的单索引	，二级索引需要自己实现</div></pre></td></tr></table></figure>
<p>  单键索引，多键索引：{x:1,y:1}<br>  数组索引：[“apple”,”lemon”]<br>  全文索引：“I am a little bird” (中文)<br>  地理位置索引：2D</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">3. 方便的冗余和扩展</div><div class="line">	1. 复制集保证数据安全</div><div class="line">	2. 分片扩展数据规模</div><div class="line"></div><div class="line">4. 良好的支持</div><div class="line">	1. 完善的文档</div><div class="line">	2. 齐全的驱动支持</div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">&gt;安装过程 略过</div><div class="line"></div><div class="line">---</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="mkdir-data"><a href="#mkdir-data" class="headerlink" title="mkdir data"></a>mkdir data</h1><h1 id="mkdir-log"><a href="#mkdir-log" class="headerlink" title="mkdir log"></a>mkdir log</h1><h1 id="mkdir-conf"><a href="#mkdir-conf" class="headerlink" title="mkdir conf"></a>mkdir conf</h1><h1 id="mkdir-bin"><a href="#mkdir-bin" class="headerlink" title="mkdir bin"></a>mkdir bin</h1><h1 id="cd-conf"><a href="#cd-conf" class="headerlink" title="cd conf"></a>cd conf</h1><h1 id="vim-mongodb-conf"><a href="#vim-mongodb-conf" class="headerlink" title="vim mongodb.conf"></a>vim mongodb.conf</h1><p>  port=27017<br>  dbpath=data<br>  logpath=log/mongod.log<br>  fork=true<br>启动 # mongod -f conf/mongodb.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">连接 mongo 121.41.31.214:27017</div><div class="line">数据库的关闭 连接时   db.shutdownServer()</div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">## mongoDB的基本操作</div><div class="line"></div><div class="line">---</div></pre></td></tr></table></figure></p>
<p>查看所有数据库</p>
<blockquote>
<p>show dbs</p>
</blockquote>
<p>切换数据库</p>
<blockquote>
<p>use dbname</p>
</blockquote>
<p>删除当前数据库,（需要先use）</p>
<blockquote>
<p>db.dropDatabase();</p>
</blockquote>
<p>创建表 (不要特殊创建 只需要use 一个不存在的name mongoDb会在需要的时候自己创建，一个表是一个集合)</p>
<blockquote>
<p>use dbname</p>
</blockquote>
<p>数据的写入  db.集合名.insert(json数据) 表集合不存在的话自动创建 _id自动创建 _id自定义时不能重复</p>
<blockquote>
<p>db.dbname_collection.insert({x:1})</p>
</blockquote>
<p>数据的查询 db.集合名.find()  参数可以为空，返回所有文档</p>
<blockquote>
<p>db.dbname_collection.find()<br>db.dbname_collection.find({x:1})   查询x=1的文档</p>
</blockquote>
<p>循环插入</p>
<blockquote>
<p>for(i=3;i&lt;100;i++)db.dbname_collection.insert({x:i})</p>
</blockquote>
<p>计数</p>
<blockquote>
<p>db.dbname_collection.find().count()</p>
</blockquote>
<p>跳过，限制条数，排序</p>
<blockquote>
<p>db.dbname_collection.find().skip(3).limit(2).sort({x:1})</p>
</blockquote>
<p>数据更新 db.集合名.find(查询条件,更新条目)  默认只会更新第一条找到的数据</p>
<blockquote>
<p>db.dbname_collection.update({x:1},{x:999})  会更新x=1的文档为 {x:999}<br>注意：db.dbname_collection.insert({x:1,y:2,z:3}) 若要更新z=3的文档 把x更新为22， 使用 db.dbname_collection.update({z:3},{x:22})  会把{x:1,y:2,z:3}整体覆盖为{x:22} </p>
</blockquote>
<p>局部更新</p>
<blockquote>
<p>db.dbname_collection.update({z:3},{$set:{x:22}})  局部更新 不会被覆盖</p>
</blockquote>
<p>更新不存在的数据，即自动创建 第三个参数 true 标示不存在的时候自动创建</p>
<blockquote>
<p>db.dbname_collection.update({x:3},{x:22},true)</p>
</blockquote>
<p>批量更新  第四个参数 true 批量更新</p>
<blockquote>
<p>db.dbname_collection.update({x:1},{$set:{x:22}},false,true)</p>
</blockquote>
<p>数据删除  必须传参，默认删除所有找的数据</p>
<blockquote>
<p>db.dbname_collection.remove({x:1})<br>db.dbname_collection.drop()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">## MongoDB索引</div><div class="line"> </div><div class="line">---</div><div class="line"></div><div class="line">#### 内容简介</div><div class="line"></div><div class="line">1. 索引的种类和使用</div><div class="line">2. 索引的匹配规则</div><div class="line">3. 如何建立合适的索引</div><div class="line">4. 索引建立的情况评估</div></pre></td></tr></table></figure>
<p>查看索引</p>
<blockquote>
<p>db.dbname_collection.getIndexes()</p>
</blockquote>
<p>创建索引  参数也是文档  1代表正向排序 -1 代表逆向排序</p>
<blockquote>
<p>db.dbname_collection.ensureIndex({x:1})</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 索引的种类</div><div class="line"></div><div class="line">1. _id索引</div><div class="line">2.  单键索引</div><div class="line">3.  多键索引</div><div class="line">4.  复合索引</div><div class="line">5.  过期索引</div><div class="line">6.  全文索引</div><div class="line">7.  地理位置索引</div><div class="line"></div><div class="line">##### _id索引</div><div class="line">* _id索引是绝大多数集合默认建立的索引</div><div class="line">* 对于每个插入的数据，MongoDB都会自动生成一条唯一的_id字段</div><div class="line"></div><div class="line">##### 单键索引</div><div class="line">* 单键索引是最普通的索引</div><div class="line">* 与_id索引不同，单键索引不会自动创建</div><div class="line"></div><div class="line">##### 多键索引</div><div class="line">* 多键索引与单键索引创建形式相同，区别在于字段的值</div><div class="line">   * 单键索引：值为单一的值，例如字符串，数字或者日期</div><div class="line">   * 多键索引：值具有多个记录，例如数组</div><div class="line">##### 复合索引</div><div class="line">* 当我们的查询条件不只有一个时，就需要建立复合索引</div><div class="line">  * 插入&#123;x:1,y:2,z:3&#125;-&gt;按照x与y的值查询-&gt;创建索引db.collection.ensureIndex(&#123;x:1,y:1&#125;)-&gt;使用&#123;x:1,y:1&#125;作为条件进行查询  </div><div class="line"></div><div class="line">##### 过期索引</div><div class="line">* 过期索引：是在一段时间后会过期的索引</div><div class="line">* 在索引过期后，相应的数据会被删除</div><div class="line">* 这适合存储一些在一些时间后会失效的数据 比如用户的登陆信息，存储的日志  </div><div class="line">* 建立方法：db.collection.ensureIndex(&#123;time:1&#125;,&#123;expireAfterSeconds:10&#125;),第二个参数是过期时间的秒数</div><div class="line">* 过期索引的限制</div><div class="line">	1. 存储在过期索引字段的值必须是指定的时间类型，说明：必须是ISODate或者ISODate数组，不能使用时间戳，否则不能被自动删除</div><div class="line">	2. 如果指定了ISODate数组，则按照最小的时间进行删除</div><div class="line">	3. 过期索引不能是复合索引</div><div class="line">	4. 删除时间是不精确的 说明：删除过程是由后台程序每60S跑一次，而且删除也需要一些时间，所以存在误差</div><div class="line"></div><div class="line">##### 全文索引 </div><div class="line">*  全文索引：对字符串与字符串数组创建全文可搜索的索引</div><div class="line">适用情况&#123;author:&quot;&quot;,title:&quot;&quot;,article:&quot;&quot;&#125;</div><div class="line">* 建立方法</div><div class="line">	db.articles.ensureIndex(&#123;key:&quot;text&quot;&#125;)</div><div class="line">	db.articles.ensureIndex(&#123;key_1:&quot;text&quot;,key_2:&quot;text&quot;&#125;)</div><div class="line">	db.articles.ensureIndex(&#123;&quot;$**&quot;:&quot;text&quot;&#125;)</div><div class="line">* 如何创建全文索引	</div><div class="line">	db.imooc_2.ensureIndex(&#123;&quot;article&quot;:&quot;text&quot;&#125;)</div><div class="line">* 如何使用全文索引进行查询</div><div class="line">	1.	db.articles.find(&#123;$text:&#123;$search:&quot;coffee&quot;&#125;&#125;)</div><div class="line">	2.	db.articles.find(&#123;$text:&#123;$search:&quot;aa bb cc&quot;&#125;&#125;) 查询 aa 或bb 或cc</div><div class="line">	3.	db.articles.find(&#123;$text:&#123;$search:&quot;aa bb -cc&quot;&#125;&#125;) 查询aa 或bb 不包含cc</div><div class="line">	4.	db.articles.find(&#123;$text:&#123;$search:&quot;\&quot;aa\&quot; \&quot;bb\&quot; \&quot;cc\&quot;&quot;&#125;&#125;) 且的关系 既包含aa也包含bb也包含cc</div><div class="line">* 全文索引的相似度</div><div class="line"> </div><div class="line">  $meta操作符：&#123;score:&#123;$meta:&quot;textScore&quot;&#125;&#125;</div><div class="line">  写在查询条件后面可以返回结果的相似度与sort一起使用，可以达到很好的实用效果	db.articles.find(&#123;$text:&#123;$search:&quot;aa bb&quot;&#125;&#125;,&#123;score:&#123;$meta:&quot;tetxScore&quot;&#125;&#125;).sort(&#123;score:&#123;$meta:&quot;tetxScore&quot;&#125;&#125;)</div><div class="line">* 全文索引的使用限制</div><div class="line">  1.每次查询，只能指定一个$text查询</div><div class="line">  2. $test查询不能出现在$nor查询中	</div><div class="line">  3. 查询中如果包含了$test,hint不再起作用</div><div class="line">  很可惜，MongoDB全文索引还不支持中文</div><div class="line"></div><div class="line">#### 索引属性</div><div class="line">1. 创建索引的格式</div><div class="line">	db,collection.ensureIndex(&#123;param&#125;,&#123;param&#125;) </div><div class="line">	其中第二个参数便是索引的属性</div><div class="line">2. 比较重要的属性有 名字 唯一性 稀疏性 是否定时删除</div><div class="line">	* 名字，name指定：db.collection.ensureIndex(&#123;&#125;,&#123;name:&quot;&quot;&#125;)</div><div class="line">	* 唯一性，unique指定：db.collection.ensureIndex(&#123;&#125;,&#123;unique:true/false&#125;)</div><div class="line">	* 稀疏性，sparse指定：db.collection.ensureIndex(&#123;&#125;,&#123;sparse:true/false&#125;) 默认是不稀疏的</div><div class="line">	db.collection.find(&#123;m:&#123;$exists:true&#125;&#125;)查询存在m的文档</div><div class="line">	db.collection.ensureIndex(&#123;m:1&#125;,&#123;sparse:true&#125;)</div><div class="line">	</div><div class="line">	db.collection.find(&#123;m:&#123;$exists:false&#125;&#125;)</div><div class="line">	**在选取索引  在稀疏索引上 查找是否存在 将不使用稀疏索引**</div><div class="line">	强制使用索引 db.collection.find(&#123;m:&#123;$exists:false&#125;&#125;).hint(&quot;m_1&quot;)</div><div class="line">	</div><div class="line">	* 是否定时删除，expireAfterSeconds指定</div><div class="line">	TTL，过期索引</div><div class="line">	 </div><div class="line">##### 地理位置索引 </div><div class="line">* 将一些点的位置存储在MongoDB中，创建索引后，可以按照位置来查找其他点</div><div class="line">  * 子分类:</div><div class="line">  1. 2d索引，用于存储和查找平面上的点。</div><div class="line">  2. 2dsphere索引，用于存储和查找球面上的点</div><div class="line">* 查找方式</div><div class="line">  * 查找距离某个点一定距离的点  </div><div class="line">  * 查找包含在某区域内的点</div></pre></td></tr></table></figure>
<p>2D索引：平面地理位置索引<br>        创建方式:db.collection.ensureIndex({w:”2d”})<br>        位置表示方式：经纬度[经度,维度]<br>        取值范围：经度[-180,180]维度[-90,90]<br>        db.collection.insert({w:[100,2]})<br>        db.collection.find({w:{$near:[1,1]}})<br>        near会返回100个离查询的点最近的点<br>        db.collection.find({w:{$near:[1,1]，$maxDistance:10}})  </p>
<pre><code>    查询方式：
    （1）$near查询：查询距离某个点最近的点
    （2）$geoWithin查询：查询某个形状内的点

    形状的标示：
    1.$box:矩形，使用
    {$box[[&lt;x1&gt;,&lt;y1&gt;],[&lt;x2&gt;,&lt;y2&gt;]]}  1.左边界 2.右边界
    2.$center:圆形，使用
    {$center:[[&lt;x1&gt;,&lt;y1&gt;],r]} 1.圆心位置 2.半径
    3.$polygon:多边形，使用
    {$polygon：[[&lt;x1&gt;,&lt;y1&gt;],[&lt;x2&gt;,&lt;y2&gt;],[&lt;x3&gt;,&lt;y3&gt;]]}

    db.collection.find({w:{$geoWithin:{$box:[[0,0],[3,3]]}}})

geoNear查询
geoNear使用runCommand命令进行使用
{
geoNear:&lt;collection&gt;,
near:[x,y],
minDistance:(对2D索引无效)
MaxDistance:
num:
}

db.runCommand({geoNear:&quot;location&quot;,near:[1,2],maxDistance:10,num:1})
</code></pre><p>2dsphere:<br>创建方式:db.collection.ensureIndex({w:”2dsphere”})<br>位置表示方式<br>GeoJson:描述一个点，一条直线，多边形等<br>格式：{type:””,coordinates:[<coordinates>]}<br>查询方式和2D索引查询方式类似<br>支持$minDistance与$maxDistance</coordinates></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">## 索引构建情况分析</div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">* 索引好处：加快索引相关的查询</div><div class="line">* 索引不好处：增加磁盘空间消耗，降低写入性能</div><div class="line"></div><div class="line">---</div><div class="line">* 如何评判当前索引构建情况</div><div class="line">	1. mongostat工具介绍</div><div class="line">	2. profile集合介绍</div><div class="line">	3. 日志介绍</div><div class="line">	4. explain分析</div><div class="line"></div><div class="line">##### mongostat工具</div><div class="line"> * mongostat查看mongodb运行状态的程序</div><div class="line"> * 使用说明	:mongostat -h 127.0.0.1:12345</div><div class="line"> </div><div class="line"> * 字段说明:</div><div class="line"> 	* inserts</div><div class="line"> 	* query</div><div class="line"> 	* update</div><div class="line"> 	* delete</div><div class="line"> 	* getmore</div><div class="line"> 	* command</div><div class="line"> 	* flushes</div><div class="line"> 	* mapped</div><div class="line"> 	* vsize</div><div class="line"> 	* res</div><div class="line"> 	* non-mapped</div><div class="line"> 	* faults</div><div class="line"> 	* locked</div><div class="line"> 	* idx miss 索引情况</div><div class="line"> 	* qr|qw</div><div class="line"> 	* ar|aw</div><div class="line"> 	* netIn</div><div class="line"> 	* netOut</div><div class="line"> 	* conn</div><div class="line"> 	* set</div><div class="line"> 	* repl</div><div class="line"> 	</div><div class="line">##### profile集合</div><div class="line"> * db.getProfilingStatus()</div><div class="line"> * db.setProfilingLevel(2)</div><div class="line"></div><div class="line"> * db.system.profile.find().sort(&#123;$natural:-1&#125;).limit(1)  </div><div class="line"> </div><div class="line">##### 日志</div><div class="line"> * mongodb.conf 中 verbose=vvvvv    v越多代表日志越详细</div><div class="line">  </div><div class="line">##### explain</div><div class="line">* db.collection.find(&#123;x:1&#125;).explain()</div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">## MongoDB 安全</div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">###安全概览</div><div class="line">1. 最安全的是物理隔离：不现实</div><div class="line">2. 网络隔离其次</div><div class="line">3. 防火墙再其次</div><div class="line">4. 用户名密码在最后</div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">#### 开启权限验证</div><div class="line">1. auth开启</div><div class="line">mongodb.conf 设置  auth=true;</div><div class="line"></div><div class="line">2. keyfile开启</div><div class="line"></div><div class="line">##### MongoDB创建用户</div><div class="line">1. 创建语法：createUser(2.6之前为addUser)</div><div class="line">2.</div></pre></td></tr></table></figure>
<p>{<br>user:”<name>“,<br>pwd:”<password>“,<br>sustomData:{&lt;说明&gt;},<br>roles;[{role:”<role>“,db:”database”}]<br>}<br>```</role></password></name></p>
<ol>
<li>角色类型：内建类型（read,readWrite,dbAdmin,dbOwner,userAdmin）</li>
</ol>
<h5 id="用户角色详解"><a href="#用户角色详解" class="headerlink" title="用户角色详解"></a>用户角色详解</h5><ol>
<li>数据库角色（read,readWrite,dbAdmin,dbOwner,userAdmin）</li>
<li>集群角色（cluterAdmin,clusterManager）</li>
<li>备份角色（backup,restore）</li>
<li>其他特殊权限（DBAdminAnyDatabase） </li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/hexoblog/categories/数据库/">数据库</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/Clover/">Clover</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexoblog/tags/MonogoDB/">MonogoDB</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>













  
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016 Clover Cui
            </div>
            <div class="footer-right">
               <!-- <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>-->
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/hexoblog/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/hexoblog//background/bg-x.jpg)".replace(/bg-x/gi, 'bg-'+Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
                //$("body").css({"background": "url(/hexoblog//background/bg-5.jpg)", "background-attachment": "fixed", "background-size": "cover"});
                
            }
        })
    </script>


    
        <script>
            if ($(".left-col").is(":visible")) {
                var duoshuoQuery = {short_name:"clovercui"};
                (function() {
                    var d = document, s = d.createElement('script');
                    s.src = 'http://static.duoshuo.com/embed.js';
                    s.async = true; s.charset = 'UTF-8';
                    (d.head || d.body).appendChild(s);
                })();

                $(document).ready(function(){
                    var $duoshuoCount = $(".ds-thread-count");
                    $duoshuoCount.bind("DOMNodeInserted", function(e) {
                        var num = $(this).text().replace(/[^0-9]/ig,"");
                        $(this).siblings(".count-comment").text(num);
                        $(this).remove();
                    })
                })
            }
        </script>
    

     




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>